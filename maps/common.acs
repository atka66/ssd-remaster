#library "common"
#include "zcommon.acs"

//////// VARIABLES AND DEFINES - START

// global scope variables

global int   1:score;
global int   2:sdr_timestamp;
global int   3:sdr_timestamp_backup;

global bool  4:sdr_triggered_lamertime;
global bool  5:sdr_common_init_firsttime;

global int   6:ssdremaster_default_sucktime;
global int   7:ssdremaster_lamertime_hours;

global int   8:ssdremaster_mock_count;

global int   9:ssdremaster_random_seed;

global int  10:keyscramble_random_results[];

global int  16:ssdremaster_game_achievements[];

// achievement variables

int ssdremaster_map_achievements[8];

bool ssdremaster_achievements_looped;

// achievement defines

#libdefine SDR_ACHIEVEMENT_TYPE_N 2

#libdefine SDR_ACHIEVEMENT_TYPE_GAME 0
#libdefine SDR_ACHIEVEMENT_TYPE_MAP 1

#libdefine SDR_GAME_ACHIEVEMENTS_N 1
#libdefine SDR_MAP_ACHIEVEMENTS_N 1

#libdefine SDR_GAME_ACHIEVEMENT_ALL_MOCKS 0

#libdefine SDR_MAP_ACHIEVEMENT_PERFECT 0

// time-related variables and defines

#libdefine SDR_TIMESTAMP_BACKUP_READY -1

int sdr_timestamp_level;

int ssdremaster_level_par_time;

bool ssdremaster_par_time_reached;

bool time_display_settings[2]; // {show_hours,show_frac_seconds}
int  time_running_settings[2]; // {tic_per_frac,frac_per_seconds}

// timebonus variable stuff

bool ssdremaster_debug_timebonus;

int timebonus_per_level[30]={
	100000, 100000, // zone  1
	100000, 100000, // zone  2
	100000, 100000, // zone  3
	100000, 100000, // zone  4
	100000, 100000, // zone  5
	100000, 100000, // zone  6
	100000, 100000, // zone  7
	100000, 100000, // zone  8
	100000, 100000, // zone  9
	100000, 100000, // zone 10
	100000, 100000, // zone 11
	100000, 100000, // zone 12
	100000, 100000, // zone 13
	100000, 100000, // zone 14
	100000, 100000, // zone 15
	};
int timebonus_down_per_gameskill[5]={100,200,300,500,750};
int timebonus_basic_setings[2]; // {timebonus,timebonus_ingame_down_unit}

int killbonus_basic_settings[3]; // {killbonus,killcount, killtarget}
int secretbonus_basic_settings[2]; // {secretbonus,secretcount}
int ringbonus_basic_settings[3]; // {rings,ringcount,ringbonus}

// monster-boss battle variable stuff

int boss_target_stats[4]; // {boss_target_hit,boss_target_max, boss_target_tid,boss_target_initial_health}

int monsters_battle_hate_intval[5]={60,50,30,20,10};

int monsters_battle_group_N=3;
int monsters_battle_group_tids[3];

int monsters_battle_killed, monsters_battle_total;

int monsters_battle_overall_health;

int monsters_battle_running;

int boss_battle_state;

#libdefine BOSS_BATTLE_STANDBY 0
#libdefine BOSS_BATTLE_ENCOUNTER 1
#libdefine BOSS_BATTLE_FINALE 2
#libdefine NOT_A_BOSS_BATTLE_LEVEL -1

int monsters_battle_state;

#libdefine MONSTERS_BATTLE_STANDBY 0
#libdefine MONSTERS_BATTLE_COMBINED 1
#libdefine MONSTERS_BATTLE_READY 2
#libdefine MONSTERS_BATTLE_ENCOUNTER 3
#libdefine MONSTERS_BATTLE_FINALE 4
#libdefine MONSTERS_BATTLE_UNAVAILABLE -1

// zone specific array definitions

int boss_target_count_borders[15][2]={
	{2, 64}, // zone  1
	{1, 64}, // zone  2
	{2, 64}, // zone  3
	{2, 64}, // zone  4
	{4, 64}, // zone  5
	{2,  8}, // zone  6
	{2,  8}, // zone  7
	{2,  8}, // zone  8
	{4,  8}, // zone  9
	{2,  8}, // zone 10
	{4,  8}, // zone 11
	{4,  8}, // zone 12
	{4,  8}, // zone 13
	{4,  8}, // zone 14
	{2,  8}  // zone 15
	};

int secret_count_per_level[30]=
	{
		 4,  2, // zone 1
		 4,  4, // zone 2
		 8,  4, // zone 3
		 5,  6, // zone 4
		 7,  3, // zone 5
		 2,  5, // zone 6
		 4,  8, // zone 7
		 4,  4, // zone 8
		 2,  2, // zone 9
		 7,  6, // zone 10
		 5,  6, // zone 11
		 4,  3, // zone 12
		 2,  7, // zone 13
		 5,  8, // zone 14
		 0,  0  // zone 15
	};

str zone_titles[15]={
	"Sunset Island Zone"  , // zone  1
	"Sunset Forest Zone"  , // zone  2
	"Skull Temple Zone"   , // zone  3
	"Nightmare Zone"      , // zone  4
	"Forest Fortress Zone", // zone  5
	"Active Volcano Zone" , // zone  6
	"Ocean City Zone"     , // zone  7
	"Crystal Palace Zone" , // zone  8
	"Nautical Mines Zone" , // zone  9
	"Steel Works Zone"    , // zone 10
	"Industrial Zone"     , // zone 11
	"Sky City Zone"       , // zone 12
	"Space Chase Zone"    , // zone 13
	"Doom Star Zone"      , // zone 14
	"Final Battle Zone"   , // zone 15
	};

// some common defines

#libdefine SSDREMASTER_MOCK_MAX_COUNT 14

// level variables and defines

#libdefine SDR_LEVELNUM_TITLEMAP 99

int zone, act;
int story_lev_num, bonus_lev_num;

// some other useful stuff

bool ready, show_hud;

bool ssdremaster_time_running;

bool ssdremaster_is_invincible;

str ssdremaster_or_music_name;

bool ssdremaster_overall_cheats;

// deep water define-variable stuff

int deepWaterN = 128;
bool deepWaterStats[128][3]; // {inDeepWater,onWaterSurface,isTopDownWater}

int sdr_water_current_base_dir;

#libdefine SDR_LIQUID_3D_TYPE_FWATER 0
#libdefine SDR_LIQUID_3D_TYPE_GWATER 1
#libdefine SDR_LIQUID_3D_TYPE_SLUDGE 2
#libdefine SDR_LIQUID_3D_TYPE_BLOOD 3
#libdefine SDR_LIQUID_3D_TYPE_NUKAGE 4
#libdefine SDR_LIQUID_3D_TYPE_LAVA 5

#libdefine SDR_LIQUID_3D_NO_DAMAGE 0
#libdefine SDR_LIQUID_3D_DAMAGE_VERY_LOW 1
#libdefine SDR_LIQUID_3D_DAMAGE_LOW 2
#libdefine SDR_LIQUID_3D_DAMAGE_MEDIUM 3
#libdefine SDR_LIQUID_3D_DAMAGE_HIGH 4
#libdefine SDR_LIQUID_3D_DAMAGE_VERY_HIGH 5
#libdefine SDR_LIQUID_3D_DAMAGE_EXTREME 6

// water damage grades (temperature): {normal, ice, colder, cold, warm, warmer, hot}

int sdr_liquid_3D_floors_chars[6][7][4]=
	{ // {damage_mod, damage_amount, damage_interval, leak_ratio}
		{{0,0,0,0}, {24,10,20,64}, {24,10,35,16}, {12, 5,20, 0}, {12, 5,35, 0}, {14,10,20,16}, {14, 25,20, 96}}, // FWATER
		{{0,0,0,0}, { 0, 0, 0, 0}, { 0, 0, 0, 0}, { 0, 0, 0, 0}, { 0, 0, 0, 0}, { 0, 0, 0, 0}, { 0,  0, 0,  0}}, // GWATER
		{{0,0,0,0}, {13,10, 0, 0}, {13,15, 0, 0}, {13,20,20, 0}, {13,20,10, 0}, {13,40,20, 0}, {13, 50,10,  0}}, // SLUDGE
		{{0,0,0,0}, {13,10, 0, 0}, {13,20, 0, 0}, {13,20,20, 0}, {13,30,20, 0}, {13,30,10, 0}, {13, 40, 5,  0}}, // BLOOD
		{{0,0,0,0}, {26,20, 0, 8}, {26,25, 0,16}, {26,30, 0,24}, {26,50, 0,32}, {26,75, 0,64}, {26,100, 0,128}}, // NUKAGE
		{{0,0,0,0}, {14,20,50, 0}, {14,20,25, 0}, {14,30, 0, 0}, {14,30,15, 0}, {14,40,10, 0}, {14, 50,10,  0}}  // LAVA
	};
int sdr_liquid_3D_floors_visual[6][9]=
	{ // {r,g,b,desat,   r_fade,g_fade,b_fade,   viscosity (friction for liquids),sink_speed (gravity)}
		{ 32, 64,192,  0,     0,  0,  0,   100,100}, // FWATER
		{128,128,128,128,   128,128,128,   100,100}, // GWATER
		{244,164,104, 64,    64, 64, 64,    85, 75}, // SLUDGE
		{192, 64, 32, 64,    32, 32, 32,   100,100}, // BLOOD
		{128,192, 64,  0,    64,128, 16,    90,125}, // NUKAGE
		{255,128,  0,128,   255,128, 32,    80, 60}  // LAVA
	};

int ssdremaster_dw_chk_water_id;
bool ssdremaster_dw_act_surface[2];

int script210_tags[2];

// forcefield variable stuff

int forceFieldN = 32;
int  forceField_intprops [32][7]; // {lid,anim_n,anim_dl,trans,cd,thrust_angle,thrust_force}
bool forceField_boolprops[32][2]; // {hurt,active}
str  forceField_strprops [32][1]; // {texStr}

// other variables

int script904_ang_n;
int endcounter;

bool ssdremaster_loop_nametag_change;

bool ssdremaster_custom_nametag;
str ssdremaster_playername;

// spawn IDs (by tiszaszaki)

#libdefine T_BOOM 161
#libdefine T_ICEJET 223
#libdefine T_FIREJET 224
#libdefine T_MINE 135
#libdefine T_HEXENARROW 209
#libdefine T_HEXENBLADE 210
#libdefine T_ICESHARD2 218

#libdefine T_REIVERFIREBALL 207
#libdefine T_REIVERFIREBALL2 212
#libdefine T_IMPFIREBALL2 201
#libdefine T_CACOFIREBALL 126
#libdefine T_CACOFIREBALL2 202
#libdefine T_ARACHNOTRONPLASMA2 205
#libdefine T_MANCUBUSFIREBALL2 204
#libdefine T_BARONFIREBALL 203
#libdefine T_BLOODSCOURGESHOT 208

#libdefine T_BANBALL 215
#libdefine T_BANIPBALL 216

#libdefine T_ENHANCEDIMP 137
#libdefine T_ENHANCEDDEMON 138
#libdefine T_ENHANCEDCACODEMON 199

#libdefine T_MINICYBERDEMON 23
#libdefine T_SUICIDALSOUL 149

#libdefine T_FIREBOMB 217
#libdefine T_MACE2 211
#libdefine T_ICEMACE 225
#libdefine T_ROCKET2 116
#libdefine T_TRACER2 9

#libdefine T_SSDROCK1 219
#libdefine T_SSDROCK2 220
#libdefine T_SSDROCK3 221
#libdefine T_SSDDIRT1 0
#libdefine T_SSDDIRT2 0
#libdefine T_SSDDIRT3 0

#libdefine T_PLASMABOLT2 206

#libdefine T_SPHERE 189
#libdefine T_RING 167
#libdefine T_SOLIDBARREL 172

// spawn variables

int ssdremaster_allkeys[6]={86,85,87,89,90,88}; // spawn ID array

int sdr_spawn_dir;

// 'key scramble' related stuff

int keyscramble_backup_results[6]={0,0,0,0,0,0};

#define SDR_KEYSCRAMBLE_BOSS_KEY_TID -666

bool ssdremaster_enable_keyscramble;
bool sdr_keyscramble_pick_onlyexist;

int keyscramble_translation_id;

str keyscramble_wall_textures[6][4]=
	{ // {keycardTex,skullkeyTex,liteTex}, for each key
		{"DOORRED","DOORRED2","LITERED" ,"SILVER4"}, // red key
		{"DOORBLU","DOORBLU2","LITEBLU4","SILVER2"}, // blue key
		{"DOORYEL","DOORYEL2","LITEYEL" ,"SILVER6"}, // yellow key
		{"DOORPUR","DOORPUR2","LITEPUR" ,"SILVER8"}, // purple key
		{"DOORGRN","DOORGRN2","LITEGRN" ,"SILVER5"}, // green key
		{"DOORORG","DOORORG2","LITEORG" ,"SILVER7"}  // orange key
	};

int keyscramble_walltex_key_N=3;
int keyscramble_walltex_all_N=4;

int keyscramble_defs_per_stage[28][6][8]=
	{
	// stagedefs: {redkey_defs,bluekey_defs,yellowkey_defs, purplekey_defs,greenkey_defs,orangekey_defs}, for each stage
	// keydefs: {lid,texPos,keyTexType, tid, stag, trigger_lid,trigger_acs,trigger_N}, for each key
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  3,0,0,  29,   0,  51,11,1},{  0,0,0,   0,   0,   0, 0,0},
			{  5,0,0,  48,   0,  53,13, 1},{  4,0,0,  30,   0,  52,12,1},{  6,0,0,  49,   0,  54,14,1}
		}, // stage  1
		{
			{111,0,0, 112,   0, 113, 8, 1},{  0,0,0,   0,   0,   0, 0,0},{112,0,0, 113,   0, 114,19,6},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage  2
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  2,0,0,  68,   0,   8, 6,1},
			{  0,0,0,   0,   0,   0, 0, 0},{  1,2,0,  67,   0,   4,10,4},{  3,0,0,  69,   0,   9,17,3}
		}, // stage  3
		{
			{ 53,1,0,  75,   0,  58,36, 8},{ 51,1,0,  51,   0,  54,34,2},{  0,0,0, 103,   0,   0, 0,0},
			{ 52,1,0,  52,   0,  56,35, 2},{  0,0,0,  50,   0,   0, 0,0},{  0,0,0, 104,   0,   0, 0,0}
		}, // stage  4
		{
			{  0,0,0,   0,   0,   0, 0, 0},{ 32,1,1,  33,   0,  43,34,4},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{ 31,1,1,  32,   0,  42,12,1},{ 30,2,1,  18,   0,  33,33,9}
		}, // stage  5
		{
			{ 32,1,1, 145,   0,  45,47, 5},{  0,0,0,   0,   0,   0, 0,0},{ 30,1,1, 143,   0,  33,45,4},
			{ 31,1,1, 144,   0,  37,46, 8},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage  6
		{
			{ 31,0,1, 166,   0,  36,27, 1},{ 33,1,1,  80,   0,  39,28,2},{ 30,1,1, 165,   0,  34, 3,2},
			{  0,0,0,   0,   0,   0, 0, 0},{ 32,1,1, 167,   0,  37, 4,2},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage  7
		{
			{ 42,1,1,-666,   0,  46,77, 2},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{ 40,1,1, 134,   0,  43,34, 1},{  0,0,0,   0,   0,   0, 0,0},{ 41,1,1, 135,   0,  44, 7,2}
		}, // stage  8
		////////////////
		{
			{ 46,1,1, 203,   0,  65,38, 5},{  0,0,0,   0,   0,   0, 0,0},{ 44,1,1, 186,   0,  51,36,6},
			{ 47,1,1, 185,   0,  70,39, 1},{ 43,1,1, 198,   0,  48,35,3},{ 45,1,1, 199,   0,  57,37,8}
		}, // stage  9
		{
			{  0,0,0,-666,   0,   0, 0, 0},{  0,0,0, 131,   0,   0, 0,0},{  0,0,0, 146,   0,   0, 0,0},
			{  0,0,0, 132,   0,   0, 0, 0},{  0,0,0, 148,   0,   0, 0,0},{  0,0,0, 130,   0,   0, 0,0}
		}, // stage 10
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 11
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 12
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 13
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 14
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 15
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 16
		////////////////
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 17
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 18
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 19
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 20
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,  64,   0,   0, 0, 0},{  0,0,0, 126,   0,   0, 0,0},{  0,0,0, 127,   0,   0, 0,0}
		}, // stage 21
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 22
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 23
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}, // stage 24
		////////////////
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,  87,  91,  33,12,1},{  0,0,0,   0,   0,   0, 0,0},
			{ 31,1,2,  88,  92,  34,12, 1},{  0,0,0,  90,  93,  36,12,1},{ 32,1,2,  89,   5,  35,12,1}
		}, // stage 25
		{
			{  0,0,0, 271, 276,  51,41, 1},{  0,0,0, 272, 277,  52,41,1},{  0,0,0, 273, 278,  53,41,1},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0, 275, 280,  55,41,1},{  0,0,0, 274, 279,  54,41,1}
		}, // stage 26
		{
			{215,1,2, 268, 270, 300,42,17},{214,1,2, 264,   3, 216,37,1},{211,1,2, 266,   4, 218,37,1},
			{213,1,2, 269,   6, 221,37, 1},{210,1,2, 265,   2, 217,37,1},{212,1,2, 267,   5, 219,37,1}
		}, // stage 27
		{
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0},
			{  0,0,0,   0,   0,   0, 0, 0},{  0,0,0,   0,   0,   0, 0,0},{  0,0,0,   0,   0,   0, 0,0}
		}  // stage 28
	};

// Icon of Sin related definitions

bool monsters_battle_icon_of_sin;
int monsters_battle_ios_spawn_N=10;
int monsters_battle_ios_spawn_IDs[10]=
	{
		137, // T_ENHANCEDIMP,
		138, // T_ENHANCEDDEMON,
		115, // T_PAINELEMENTAL,
		199, // T_ENHANCEDCACODEMON,
		111, // T_VILE,
		 20, // T_REVENANT,
		  6, // T_ARACHNOTRON,
		112, // T_MANCUBUS,
		113, // T_HELLKNIGHT,
		  3  // T_BARON
	};

// bonus stage related variables-defines (by tiszaszaki)

int bonus_stage_state;

#libdefine BONUS_STAGE_PLAYING 0
#libdefine BONUS_STAGE_WIN 1
#libdefine BONUS_STAGE_LOSE 2
#libdefine NOT_A_BONUS_STAGE -1

// boss related defines - seven deadly sinners

#libdefine SDR_SEVENSINNER_BOSS_ENVY 0
#libdefine SDR_SEVENSINNER_BOSS_LUST 1
#libdefine SDR_SEVENSINNER_BOSS_SLOTH 2
#libdefine SDR_SEVENSINNER_BOSS_GREED 3
#libdefine SDR_SEVENSINNER_BOSS_VANITY 4
#libdefine SDR_SEVENSINNER_BOSS_GLUTTONY 5
#libdefine SDR_SEVENSINNER_BOSS_PRIDE 6
#libdefine SDR_SEVENSINNER_THEFIRESTARTER 7 // head of the seven sinners

// boss related variables - seven deadly sinners

bool ssdremaster_sevensinner_anim[8];

bool ssdremaster_boss_health_engaged=false;

str ssdremaster_sevensinner_names[8]=
	{
		"Envy",
		"Lust",
		"Sloth",
		"Greed",
		"Vanity",
		"Gluttony",
		"Pride",
		"The Firestarter"
	};

int ssdremaster_sevensinner_tids[8]={85,57,46,22,-1,43,230,1336};

int ssdremaster_sevensinner_colhead[8][2]=
	{
		{2,2}, // Envy
		{2,2}, // Lust
		{2,2}, // Sloth
		{2,2}, // Greed
		{2,2}, // Vanity
		{1,1}, // Gluttony
		{1,1}, // Pride
		{3,2}  // The Firestarter
	};

int ssdremaster_sevensinner_colvals[8][4]=
	{
		{ 3,16, 0, 0}, // Envy
		{ 6,17, 0, 0}, // Lust
		{ 4,18, 0, 0}, // Sloth
		{ 7,19, 0, 0}, // Greed
		{ 2,20, 0, 0}, // Vanity
		{ 8, 0, 0, 0}, // Gluttony
		{10, 0, 0, 0}, // Pride
		{ 6, 8, 5, 0}  // The Firestarter
	};

bool ssdremaster_sevensinner_death[8];

int ssdremaster_sevensinner_keydrop[8]={1,1,0,1,0,0,0,7};
int ssdremaster_sevensinner_deadacs[8]={21,16, 9,20, 0,31,39, 5};
int ssdremaster_sevensinner_stopacs[8]={36,33,42,32, 0,33,40, 0};

// boss related variables - other

#libdefine SDR_OTHER_BOSS_GIANTMANCUBUS 0
#libdefine SDR_OTHER_BOSS_SPIDERDEMON 1
#libdefine SDR_OTHER_BOSS_CYBERDEMON 2
#libdefine SDR_OTHER_BOSS_SUPERMANCUBUS 3
#libdefine SDR_OTHER_BOSS_SUPERSPIDERDEMON 4
#libdefine SDR_OTHER_BOSS_SUPERCYBERDEMON 5
#libdefine SDR_OTHER_BOSS_SURPRISE 6

int ssdremaster_other_boss_names[7]=
	{
		"Giant Mancubus",
		"Spider Mastermind",
		"Cyberdemon",
		"Super Mancubus",
		"Super Spiderdemon",
		"Super Cyberdemon",
		"???"
	};

int ssdremaster_other_boss_colhead[7][2]=
	{
		{2,2}, // Giant Mancubus
		{1,2}, // Spider Mastermind
		{1,2}, // Cyberdemon
		{6,2}, // Super Mancubus
		{6,2}, // Super Spiderdemon
		{6,2}, // Super Cyberdemon
		{1,2}  // ???
	};

int ssdremaster_other_boss_colvals[7][8]=
	{
		{ 1, 0, 0, 0, 0, 0, 0, 0}, // Giant Mancubus
		{ 1, 0, 0, 0, 0, 0, 0, 0}, // Spider Mastermind
		{ 1, 0, 0, 0, 0, 0, 0, 0}, // Cyberdemon
		{ 6, 8,10, 3, 7,19, 0, 0}, // Super Mancubus
		{ 6, 8,10, 3, 7,19, 0, 0}, // Super Spiderdemon
		{ 6, 8,10, 3, 7,19, 0, 0}, // Super Cyberdemon
		{-1, 0, 0, 0, 0, 0, 0, 0}  // ???
	};

bool ssdremaster_other_boss_death;

// boss related variables - monster-based

bool ssdremaster_monster_battle_cd;

// variables for scoring

int timebonus_rundown_unit = 1000;
int killbonus_rundown_unit = 250;
int secretbonus_rundown_unit = 250;

int ringbonus_rundown_unit = 200;

int rundown_dl=2;

bool ssdremaster_do_scoring;

// variables for secret reveal

bool sdr_reveal_secret_message_ready;

#libdefine SDR_SECRET_REVEAL_NORMAL 0
#libdefine SDR_SECRET_REVEAL_MOCK 1
#libdefine SDR_SECRET_REVEAL_BONUS 2

//// variables for weapons/items

int ammo_a[5]; // {ammo1,ammo2,ammo3,ammo4,ammo5}
int capacity_a[4]; // {capacity1,capacity2,capacity3,capacity4}
int weapons_a[9]; // {weapon1,weapon2,weapon3,weapon33,weapon4,weapon5,weapon6,weapon7,weapon8}

int pack;
int health;
int armour;

// variables for display functions

str common_monster_disp_pref_def="Monsters:";
str common_monster_display_prefix="Monsters:"; // redundant var declarations

str common_sumhealth_display_prefix="Overall health:";
str common_trghealth_display_prefix="Target health:";

str common_target_display_prefix="Target:";
str common_time_display_prefix="Time:";
str common_score_display_prefix="Score:";
str common_ring_display_prefix="Rings:";

str common_timebonus_display_prefix="Time bonus:";
str common_leveltime_display_prefix="Level time:";

bool sdr_show_overall_health=false;

//////// VARIABLES AND DEFINES - END

// random functions

// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm. (ZDoom ACS variant)
function int ssdremaster_jenkins_hash_step( int x )
{
	x = x + ( x << 10 );
	x = x ^ ( x >> 06 );
	x = x + ( x << 03 );
	x = x ^ ( x >> 11 );
	x = x + ( x << 15 );

	return x;
}

function void ssdremaster_init_random_seed(bool first_time)
{
	ssdremaster_random_seed = ThingCount(0, 0);
}

function void ssdremaster_execute_random_hash(void)
{
	ssdremaster_random_seed = ssdremaster_random_seed ^ ssdremaster_jenkins_hash_step(ssdremaster_random_seed);
}

function int ssdremaster_hashRandom(int low,int high)
{
	int res=0;

	if (low <= high)
	{
		res = low;

		if (low < high)
		{
			int spread=(high - low) + 1;

			ssdremaster_execute_random_hash();

			res += ssdremaster_random_seed % spread;
		}
	}

	return res;
}

function int ssdremaster_RandomBoost(int low,int high, int min_n,int max_n, bool jenkins)
{
	int res=0;

	if ((low <= high) && (min_n > 0) && (min_n <= max_n))
	{
		res = low;

		if (low < high)
		{
			int i,n=min_n;

			if (min_n < max_n)
			{
				if (jenkins)
					n = ssdremaster_hashRandom(min_n, max_n);
				else
					n = Random(min_n, max_n);
			}

			for (i=0;i<n;i++)
			{
				if (jenkins)
					res = ssdremaster_hashRandom(low, high);
				else
					res = Random(low, high);
			}
		}
	}

	return res;
}

// 'key scramble' functions

function str ssdremaster_queryKeyName(int lock_id, bool capital)
{
	int ssdremaster_allkeys_N=6;

	str res="";

	if ((lock_id >= 1) && (lock_id <= ssdremaster_allkeys_N))
	{
		switch (lock_id)
		{
			case 1:
			{
				if (capital) { res = "Red"; } else { res = "red"; }
			} break;
			case 2:
			{
				if (capital) { res = "Blue"; } else { res = "blue"; }
			} break;
			case 3:
			{
				if (capital) { res = "Yellow"; } else { res = "yellow"; }
			} break;
			case 4:
			{
				if (capital) { res = "Purple"; } else { res = "purple"; }
			} break;
			case 5:
			{
				if (capital) { res = "Green"; } else { res = "green"; }
			} break;
			case 6:
			{
				if (capital) { res = "Orange"; } else { res = "orange"; }
			} break;
			default: break; // unknown type of lock
		}	
	}

	return res;
}

function void keyscramble_clear_results(void)
{
	int ssdremaster_allkeys_N=6;
	int i,n;

	n = ssdremaster_allkeys_N;
	for (i=0;i<n;i++)
		keyscramble_random_results[i] = 0;
}

function bool keyscramble_check_sectlit(void)
{
	bool ssdremaster_keyscramble_sectlit=(GetCVar("ssdremaster_keyscramble_allow_sector_light_effects") != 0);

	return ssdremaster_keyscramble_sectlit;
}

function bool keyscramble_check_backup(bool logged)
{
	bool res=false;
	int ssdremaster_allkeys_N=6;
	int i,n;

	str logStr="[keyscramble_check_backup] ";

	n = ssdremaster_allkeys_N;
	for (i=0;i<n;i++)
	{
		int e=keyscramble_backup_results[i];
		res |= (e > 0);
		logStr = StrParam(s:logStr,d:e,s:";");
	}

	if (logged) Log(s:logStr,s:" (",d:res,s:")");

	return res;
}

function void keyscramble_make_backup(void)
{
	if (!keyscramble_check_backup(false))
	{
		bool has_results=false;
		int ssdremaster_allkeys_N=6;
		int i,n;

		n = ssdremaster_allkeys_N;
		for (i=0;i<n;i++)
			has_results |= (keyscramble_random_results[i] > 0);

		if (has_results)
		{
			for (i=0;i<n;i++)
				keyscramble_backup_results[i] = keyscramble_random_results[i];
		}
	}
}

function void keyscramble_drop_backup(void)
{
	if (keyscramble_check_backup(false))
	{
		int ssdremaster_allkeys_N=6;
		int i,n;

		n = ssdremaster_allkeys_N;
		for (i=0;i<n;i++)
			keyscramble_backup_results[i] = 0;
	}
}

function void init_keyscramble_for_stage(int stagenum)
{
	bool keyscramble_debug=(GetCVar("ssdremaster_debug_keyscramble") != 0);

	int ssdremaster_allkeys_N=6;
	int keyscramble_samples[6];

	if ((stagenum >= 1) && (stagenum <= 30))
	{
		int i,n, j,m;

		int tid;

		str temp;

		n = ssdremaster_allkeys_N;

		if (sdr_keyscramble_pick_onlyexist)
		{
			m = 0;

			for (i=0;i<n;i++)
			{
				tid = keyscramble_defs_per_stage[stagenum-1][i][3];

				if (tid > 0)
				{
					keyscramble_samples[m] = i;
					m++;
				}
			}
		}
		else
		{
			m = n;

			for (i=0;i<n;i++)
				keyscramble_samples[i] = i;
		}

		if (keyscramble_debug)
		{
			temp = "[init_keyscramble] ";
			for (j=0;j<m;j++)
				temp = StrParam(s:temp,d:keyscramble_samples[j],s:";");

			Log(s:temp);
		}

		n = ssdremaster_allkeys_N;

		for (i=0;i<n;i++)
		{
			int lid=        keyscramble_defs_per_stage[stagenum-1][i][0];
			int texPos=     keyscramble_defs_per_stage[stagenum-1][i][1];
			int keyTexType= keyscramble_defs_per_stage[stagenum-1][i][2];

			int stag=       keyscramble_defs_per_stage[stagenum-1][i][4];

			int trigger_lid=keyscramble_defs_per_stage[stagenum-1][i][5];
			int trigger_acs=keyscramble_defs_per_stage[stagenum-1][i][6];
			int trigger_N=  keyscramble_defs_per_stage[stagenum-1][i][7];

			tid = keyscramble_defs_per_stage[stagenum-1][i][3];

			if ((m > 0) && ((tid > 0) || (tid == SDR_KEYSCRAMBLE_BOSS_KEY_TID)))
			if (((lid >= 0) && (texPos >= 0) && (texPos <= 2) && (keyTexType >= 0) && (keyTexType < keyscramble_walltex_key_N)) && (stag >= 0))
			if ((trigger_lid >= 0) && (trigger_acs >= 0) && (trigger_N >= 0))
			{
				int ind,res;

				do
				{
					ind = ssdremaster_RandomBoost(0,m-1, 8,16, false);
					res = keyscramble_samples[ind];
				}
				while ((m >= 2) && (res == i));

				if (ind < m-1)
				{
					for (j=ind;j<m-1;j++)
						keyscramble_samples[j] = keyscramble_samples[j+1];

					keyscramble_samples[m-1] = 0;
				}
				else
				{
					keyscramble_samples[ind] = 0;
				}

				m--;

				keyscramble_random_results[i] = res + 1;
				if (keyscramble_debug) Log(s:"[init_keyscramble] ",d:i,s:" -> ",d:res);

				if (keyscramble_debug && (m > 0))
				{
					temp = "[init_keyscramble] ";
					for (j=0;j<m;j++)
						temp = StrParam(s:temp,d:keyscramble_samples[j],s:";");

					Log(s:temp);
				}
			}
		}

		if (keyscramble_debug)
		{
			temp = "[init_keyscramble] result: ";

			n = ssdremaster_allkeys_N;

			for (i=0;i<n;i++)
				temp = StrParam(s:temp,d:keyscramble_random_results[i],s:";");

			Log(s:temp);
		}
	}
}

function void apply_keyscramble_for_stage(int stagenum)
{
	bool ssdremaster_keyscramble_locktex=(GetCVar("ssdremaster_keyscramble_allow_lock_textures") != 0);
	bool ssdremaster_keyscramble_sectlit=(GetCVar("ssdremaster_keyscramble_allow_sector_light_effects") != 0);

	int ssdremaster_allkeys_N=6;
	str ssdremaster_allkeys_str[6];

	int tid_off_for_swap=10000;

	if ((stagenum >= 1) && (stagenum <= 30))
	{
		int i,n, j,m;

		ssdremaster_allkeys_str[0]="RedCard2";
		ssdremaster_allkeys_str[1]="BlueCard2";
		ssdremaster_allkeys_str[2]="YellowCard2";
		ssdremaster_allkeys_str[3]="PurpleCard";
		ssdremaster_allkeys_str[4]="GreenCard";
		ssdremaster_allkeys_str[5]="OrangeCard";

		n = ssdremaster_allkeys_N;

		for (i=0;i<n;i++)
		{
			int random_res=keyscramble_random_results[i];

			if ((random_res >= 1) && (random_res <= ssdremaster_allkeys_N))
			{
				int lid=        keyscramble_defs_per_stage[stagenum-1][i][0];
				int texPos=     keyscramble_defs_per_stage[stagenum-1][i][1];
				int keyTexType= keyscramble_defs_per_stage[stagenum-1][i][2];
				int tid=        keyscramble_defs_per_stage[stagenum-1][i][3];
				int stag=       keyscramble_defs_per_stage[stagenum-1][i][4];

				int trigger_lid=keyscramble_defs_per_stage[stagenum-1][i][5];
				int trigger_acs=keyscramble_defs_per_stage[stagenum-1][i][6];
				int trigger_N=  keyscramble_defs_per_stage[stagenum-1][i][7];

				str keyspawnclass=ssdremaster_allkeys_str[random_res-1];
				int newtid=tid + tid_off_for_swap;

				if (ssdremaster_keyscramble_locktex && (lid > 0))
				{
					//str oldKeyTex=keyscramble_wall_textures[i         ][keyTexType]; // used for checking real texture
					str newKeyTex=keyscramble_wall_textures[random_res-1][keyTexType];

					SetLineTexture(lid, SIDE_FRONT, 2 - texPos, newKeyTex);
				}

				if (ssdremaster_keyscramble_sectlit && (stag > 0)) // WIP
				{
					int r,g,b;

					switch (random_res)
					{
						case 1: { r = 255; g =   0; b =   0; } break; // red key
						case 2: { r =   0; g =   0; b = 255; } break; // blue key
						case 3: { r = 255; g = 255; b =   0; } break; // yellow key
						case 4: { r = 255; g =   0; b = 255; } break; // purple key
						case 5: { r =   0; g = 255; b =   0; } break; // green key
						case 6: { r = 255; g = 128; b =   0; } break; // orange key
						default: break;
					}

					Sector_SetColor(stag, r,g,b);
				}

				if (tid > 0)
				{
					SpawnSpotForced(keyspawnclass, tid, newtid, 0);
					Thing_Remove(tid);
					Thing_ChangeTID(newtid, tid);
				}

				if ((trigger_lid > 0) && (trigger_acs > 0) && (trigger_N > 0))
				{
					m = trigger_N;

					for (j=0;j<m;j++)
						SetLineSpecial(trigger_lid + j, 83, trigger_acs,0,j,0,random_res);
				}
			}
		}
	}
}

function void keyscramble_translation(int light_tid1, int light_translate1, int light_tid2, int light_translate2, int light_tid3, int light_translate3,
	int light_tid4, int light_translate4, int light_tid5, int light_translate5, int light_tid6, int light_translate6, int litsrc_id)
{
	bool ssdremaster_keyscramble_actlite=(GetCVar("ssdremaster_keyscramble_allow_light_sources") != 0);
	bool ssdremaster_keyscramble_actmisc=(GetCVar("ssdremaster_keyscramble_allow_other_obstacles") != 0);

	str debug_common_prefix=StrParam(s:"[keyscramble_translation_",d:keyscramble_translation_id+1,s:"]");

	if (ssdremaster_enable_keyscramble)
	{
		int ssdremaster_allkeys_N=6;
		bool keyscramble_debug=(GetCVar("ssdremaster_debug_keyscramble") != 0);

		str keyscramble_light_sources[6];
		int i,n;

		switch (litsrc_id)
		{
			case 0:
			{
				keyscramble_light_sources[0] = "ColumnRed";
				keyscramble_light_sources[1] = "ColumnBlue";
				keyscramble_light_sources[2] = "ColumnYellow";
				keyscramble_light_sources[3] = "ColumnPurple";
				keyscramble_light_sources[4] = "ColumnGreen";
				keyscramble_light_sources[5] = "ColumnOrange";
			} break;
			case 1:
			{
				keyscramble_light_sources[0] = "RedTorch";
				keyscramble_light_sources[1] = "BlueTorch";
				keyscramble_light_sources[2] = "YellowTorch";
				keyscramble_light_sources[3] = "PurpleTorch";
				keyscramble_light_sources[4] = "GreenTorch";
				keyscramble_light_sources[5] = "OrangeTorch";
			} break;
			case 2:
			{
				keyscramble_light_sources[0] = "ShortRedTorch";
				keyscramble_light_sources[1] = "ShortBlueTorch";
				keyscramble_light_sources[2] = "ShortYellowTorch";
				keyscramble_light_sources[3] = "ShortPurpleTorch";
				keyscramble_light_sources[4] = "ShortGreenTorch";
				keyscramble_light_sources[5] = "ShortOrangeTorch";
			} break;
			default:
			{
				n = ssdremaster_allkeys_N;
				for (i=0;i<n;i++)
					keyscramble_light_sources[i] = "";
			} break;
		}

		if ((light_tid1 >= 0) && (light_tid2 >= 0) && (light_tid3 >= 0))
		if ((light_tid4 >= 0) && (light_tid5 >= 0) && (light_tid6 >= 0))
		if ((light_translate1 >= -1) && (light_translate2 >= -1) && (light_translate3 >= -1))
		if ((light_translate4 >= -1) && (light_translate5 >= -1) && (light_translate6 >= -1))
		{
			int tid_off_for_swap=10000;
			bool is_light_source=true;

			bool success=false;
			bool use_backup=(keyscramble_check_backup(keyscramble_debug));

			n = ssdremaster_allkeys_N;
			for (i=1;i<=n;i++)
			{
				int random_res=0;

				int light_tid=0;
				str light_class1, light_class2;

				int light_count=0;

				if (use_backup)
					random_res = keyscramble_backup_results[i-1];
				else
					random_res = keyscramble_random_results[i-1];

				if ((random_res < 1) || (random_res > ssdremaster_allkeys_N)) continue;

				switch (i)
				{
					case 1: light_tid = light_tid1; break;
					case 2: light_tid = light_tid2; break;
					case 3: light_tid = light_tid3; break;
					case 4: light_tid = light_tid4; break;
					case 5: light_tid = light_tid5; break;
					case 6: light_tid = light_tid6; break;
					default: break;
				}

				if ((i == random_res) || (light_tid <= 0)) continue;

				light_class1 = keyscramble_light_sources[i-1];
				light_class2 = keyscramble_light_sources[random_res-1];

				if ((StrCmp(light_class1,"") == 0) || (StrCmp(light_class2,"") == 0))
					is_light_source = false;
				else
				{
					if (keyscramble_debug) Log(s:debug_common_prefix,s:" key #",d:i,s:" original class: '",s:GetActorClass(light_tid),s:"'");
					is_light_source &= (CheckActorClass(light_tid, light_class1));
				}

				if (is_light_source)
					light_count = ThingCount(0, light_tid);

				if (is_light_source)
				{
					if (keyscramble_debug) Log(s:debug_common_prefix,s:" key #",d:i,s:" classes: '",s:light_class1,s:"' and '",s:light_class2,s:"'");
					if (keyscramble_debug) Log(s:debug_common_prefix,s:" key #",d:i,s:" count: ",d:light_count);
				}

				if (is_light_source && ssdremaster_keyscramble_actlite && (light_count > 0))
				{
					int newtid = light_tid + tid_off_for_swap;

					if (keyscramble_debug) Log(s:debug_common_prefix,s:" key #",d:i,s:" -> ",s:light_class2);

					SpawnSpotForced(light_class2, light_tid, newtid, 0);
					Thing_Remove(light_tid);
					Thing_ChangeTID(newtid, light_tid);
				}
				
				if ( (is_light_source && ssdremaster_keyscramble_actlite) ||
					(!is_light_source && ssdremaster_keyscramble_actmisc) )
				{
					int light_translate=-1;

					switch (random_res)
					{
						case 1: light_translate = light_translate1; break;
						case 2: light_translate = light_translate2; break;
						case 3: light_translate = light_translate3; break;
						case 4: light_translate = light_translate4; break;
						case 5: light_translate = light_translate5; break;
						case 6: light_translate = light_translate6; break;
						default: break;
					}

					if (keyscramble_debug) Log(s:debug_common_prefix,s:" key #",d:i,s:" translation: ",d:light_translate);

					Thing_SetTranslation(light_tid, light_translate);
				}

				success = true;
			}

			if (success)
				keyscramble_translation_id++;
		}
	}
}

function void keyscramble_replace_textures(int lid1, int lid1pos, int lid2, int lid2pos, int lid3, int lid3pos,
	int lid4, int lid4pos, int lid5, int lid5pos, int lid6, int lid6pos, int texType)
{
	bool ssdremaster_keyscramble_misctex=(GetCVar("ssdremaster_keyscramble_allow_other_textures") != 0);

	if (ssdremaster_enable_keyscramble && ssdremaster_keyscramble_misctex)
	{
		int ssdremaster_allkeys_N=6;

		int i,n;

		if ((texType >= keyscramble_walltex_key_N) && (texType <= keyscramble_walltex_all_N))
		if ((lid1 >= 0) && (lid1pos >= 0) && (lid1pos <= 2))
		if ((lid2 >= 0) && (lid2pos >= 0) && (lid2pos <= 2))
		if ((lid3 >= 0) && (lid3pos >= 0) && (lid3pos <= 2))
		if ((lid4 >= 0) && (lid4pos >= 0) && (lid4pos <= 2))
		if ((lid5 >= 0) && (lid5pos >= 0) && (lid5pos <= 2))
		if ((lid6 >= 0) && (lid6pos >= 0) && (lid6pos <= 2))
		{
			n = ssdremaster_allkeys_N;
			for (i=1;i<=n;i++)
			{
				int random_res=keyscramble_random_results[i-1];

				int lid, texPos;
				str newTex;

				if ((random_res < 1) || (random_res > ssdremaster_allkeys_N)) continue;

				switch (i)
				{
					case 1: { lid = lid1; texPos = lid1pos; } break;
					case 2: { lid = lid2; texPos = lid2pos; } break;
					case 3: { lid = lid3; texPos = lid3pos; } break;
					case 4: { lid = lid4; texPos = lid4pos; } break;
					case 5: { lid = lid5; texPos = lid5pos; } break;
					case 6: { lid = lid6; texPos = lid6pos; } break;
					default: break;
				}

				if ((i == random_res) || (lid <= 0)) continue;

				newTex = keyscramble_wall_textures[random_res-1][texType];

				SetLineTexture(lid, SIDE_FRONT, 2 - texPos, newTex);
			}
		}
	}
}

function void keyscramble_sectlite_per_key(int tag1, int tag2, int tag3, int tag4, int tag5, int tag6,
	int tag7, int tag8, int tag9, int tag10, int tag11, int tag12, int key_i)

{
	bool ssdremaster_keyscramble_sectlit=(GetCVar("ssdremaster_keyscramble_allow_sector_light_effects") != 0);

	if (ssdremaster_enable_keyscramble && ssdremaster_keyscramble_sectlit)
	{
		int ssdremaster_allkeys_N=6;

		if ((key_i >= 1) && (key_i <= ssdremaster_allkeys_N))
		if ((tag1  >= 0) && (tag2  >= 0) && (tag3  >= 0))
		if ((tag4  >= 0) && (tag5  >= 0) && (tag6  >= 0))
		if ((tag7  >= 0) && (tag8  >= 0) && (tag9  >= 0))
		if ((tag10 >= 0) && (tag11 >= 0) && (tag12 >= 0))
		{
			int random_res=keyscramble_random_results[key_i-1];

			int r,g,b;

			if ((random_res < 1) || (random_res > ssdremaster_allkeys_N)) return;

			switch (random_res)
			{
				case 1: { r = 255; g =   0; b =   0; } break; // red key
				case 2: { r =   0; g =   0; b = 255; } break; // blue key
				case 3: { r = 255; g = 255; b =   0; } break; // yellow key
				case 4: { r = 255; g =   0; b = 255; } break; // purple key
				case 5: { r =   0; g = 255; b =   0; } break; // green key
				case 6: { r = 255; g = 128; b =   0; } break; // orange key
				default: break;
			}

			if (tag1  > 0) Sector_SetColor(tag1,  r,g,b);
			if (tag2  > 0) Sector_SetColor(tag2,  r,g,b);
			if (tag3  > 0) Sector_SetColor(tag3,  r,g,b);
			if (tag4  > 0) Sector_SetColor(tag4,  r,g,b);
			if (tag5  > 0) Sector_SetColor(tag5,  r,g,b);
			if (tag6  > 0) Sector_SetColor(tag6,  r,g,b);
			if (tag7  > 0) Sector_SetColor(tag7,  r,g,b);
			if (tag8  > 0) Sector_SetColor(tag8,  r,g,b);
			if (tag9  > 0) Sector_SetColor(tag9,  r,g,b);
			if (tag10 > 0) Sector_SetColor(tag10, r,g,b);
			if (tag11 > 0) Sector_SetColor(tag11, r,g,b);
			if (tag12 > 0) Sector_SetColor(tag12, r,g,b);
		}
	}
}

// deep water 3D floor definitions

function void ssdremaster_3D_liquid_effects(int tag1, int tag2, int tag3, int tag4, int liquid_type, int liquid_damage)
{
	if ((tag1 > 0) || (tag2 > 0) || (tag3 > 0) || (tag4 > 0))
	if ((liquid_type >= SDR_LIQUID_3D_TYPE_FWATER) && (liquid_type <= SDR_LIQUID_3D_TYPE_LAVA))
	if ((liquid_damage >= SDR_LIQUID_3D_NO_DAMAGE) && (liquid_damage <= SDR_LIQUID_3D_DAMAGE_EXTREME))
	{
		int r=         sdr_liquid_3D_floors_visual[liquid_type][0];
		int g=         sdr_liquid_3D_floors_visual[liquid_type][1];
		int b=         sdr_liquid_3D_floors_visual[liquid_type][2];
		int desat=     sdr_liquid_3D_floors_visual[liquid_type][3];

		int r_fade=    sdr_liquid_3D_floors_visual[liquid_type][4];
		int g_fade=    sdr_liquid_3D_floors_visual[liquid_type][5];
		int b_fade=    sdr_liquid_3D_floors_visual[liquid_type][6];

		int viscosity= sdr_liquid_3D_floors_visual[liquid_type][7];
		int sink_speed=sdr_liquid_3D_floors_visual[liquid_type][8];

		int damage_mod     =sdr_liquid_3D_floors_chars[liquid_type][liquid_damage][0];
		int damage_amount  =sdr_liquid_3D_floors_chars[liquid_type][liquid_damage][1];
		int damage_interval=sdr_liquid_3D_floors_chars[liquid_type][liquid_damage][2];
		int leak_ratio     =sdr_liquid_3D_floors_chars[liquid_type][liquid_damage][4];

		if ((r >= 0) && (r <= 255))
		if ((g >= 0) && (g <= 255))
		if ((b >= 0) && (b <= 255))
		if ((desat >= 0) && (desat <= 255))
		if ((r_fade >= 0) && (r_fade <= 255))
		if ((g_fade >= 0) && (g_fade <= 255))
		if ((b_fade >= 0) && (b_fade <= 255))
		{
			if (tag1 > 0)
			{
				Sector_SetColor(tag1, r,g,b, desat);
				Sector_SetFade(tag1, r_fade,g_fade,b_fade);
			}

			if (tag2 > 0)
			{
				Sector_SetColor(tag2, r,g,b, desat);
				Sector_SetFade(tag2, r_fade,g_fade,b_fade);
			}

			if (tag3 > 0)
			{
				Sector_SetColor(tag3, r,g,b, desat);
				Sector_SetFade(tag3, r_fade,g_fade,b_fade);
			}

			if (tag4 > 0)
			{
				Sector_SetColor(tag4, r,g,b, desat);
				Sector_SetFade(tag4, r_fade,g_fade,b_fade);
			}
		}

		if (damage_mod >= 0)
		if ((damage_amount > 0) && (damage_interval >= 0))
		if ((leak_ratio >= 0) && (leak_ratio <= 256))
		{
			if (tag1 > 0)
				Sector_SetDamage(tag1, damage_amount, damage_mod, damage_interval, leak_ratio);

			if (tag2 > 0)
				Sector_SetDamage(tag2, damage_amount, damage_mod, damage_interval, leak_ratio);

			if (tag3 > 0)
				Sector_SetDamage(tag3, damage_amount, damage_mod, damage_interval, leak_ratio);

			if (tag4 > 0)
				Sector_SetDamage(tag4, damage_amount, damage_mod, damage_interval, leak_ratio);
		}
	}

	if ((viscosity > 0) && (viscosity != 100))
	{
		if (tag1 > 0)
			Sector_SetFriction(tag1, viscosity);

		if (tag2 > 0)
			Sector_SetFriction(tag2, viscosity);

		if (tag3 > 0)
			Sector_SetFriction(tag3, viscosity);

		if (tag4 > 0)
			Sector_SetFriction(tag4, viscosity);
	}

	if ((sink_speed > 0) && (sink_speed != 100))
	{
		int sink_speed_i=sink_speed / 100;
		int sink_speed_f=sink_speed % 100;

		if (tag1 > 0)
			Sector_SetGravity(tag1, sink_speed_i, sink_speed_f);

		if (tag2 > 0)
			Sector_SetGravity(tag2, sink_speed_i, sink_speed_f);

		if (tag3 > 0)
			Sector_SetGravity(tag3, sink_speed_i, sink_speed_f);

		if (tag4 > 0)
			Sector_SetGravity(tag4, sink_speed_i, sink_speed_f);
	}
}

// deep water effect scripts (by tiszaszaki)

// common

function int ssdremaster_deepwater_check(int activator, int wtag, int wtid, bool top_down, bool log_check)
{
	int x=GetActorX(wtid);
	int y=GetActorY(wtid);

	int sfloor=GetSectorFloorZ(wtag, x,y);
	int playerEyeHeight=(GetActorZ(activator) - sfloor) + GetActorViewHeight(activator);
	int waterSurfaceHeight=GetSectorCeilingZ(wtag, x,y) - sfloor;

	int res=0;

	if (log_check)
	{
		str log_str="ssdremaster_deepwater_check";

		if (ssdremaster_dw_chk_water_id >= 0)
			log_str = StrParam(s:log_str,s:" (water id:",d:ssdremaster_dw_chk_water_id,s:")");

		log_str = StrParam(s:log_str,s:": ",d:playerEyeHeight >> 16,s:" ? ",d:waterSurfaceHeight >> 16,s:" (",d:sfloor >> 16,s:")");

		Log(s:log_str);
	}

	if (top_down)
	{
		if (playerEyeHeight < 0) res = 1;
		if (playerEyeHeight > 0) res = -1;
	}
	else
	{
		if (playerEyeHeight < waterSurfaceHeight) res = -1;
		if (playerEyeHeight > waterSurfaceHeight) res = 1;
	}

	return res;
}

// splashing

script "ssdremaster_deepwater_in" (int i, int log_i) // in
{
	if ((i >= 0) && (i < deepWaterN))
	{
		bool log_splash=(log_i != 0);

		if (!deepWaterStats[i][0])
		{
			if (log_splash) Log(s:"ssdremaster_deepwater_in: splashing (water id:",d:i,s:")");

			PlaySound(0,"splash");
			deepWaterStats[i][0]=true;
		}
	}
}

script "ssdremaster_deepwater_out" (int i, int log_i) // out
{
	if ((i >= 0) && (i < deepWaterN))
	{
		bool log_splash=(log_i != 0);

		if (deepWaterStats[i][0])
		{
			if (log_splash) Log(s:"ssdremaster_deepwater_out: splashing (water id:",d:i,s:")");

			PlaySound(0,"splash");
			deepWaterStats[i][0]=false;
		}
	}
}

script "ssdremaster_deepwater_do_splash" (int i, int wtag, int wtid)
{
	if ((i >= 0) && (i < deepWaterN) && (wtag > 0) && (wtid > 0))
	{
		bool log_check=false;
		bool log_splash=false;

		while (deepWaterStats[i][1])
		{
			int checkVal;
			int dl=2;

			ssdremaster_dw_chk_water_id = i;

			checkVal = ssdremaster_deepwater_check(0, wtag, wtid, deepWaterStats[i][2], log_check);

			if (checkVal < 0)
				ACS_NamedExecute("ssdremaster_deepwater_in", 0, i,log_splash,0);
			if (checkVal > 0)
				ACS_NamedExecute("ssdremaster_deepwater_out", 0, i,log_splash,0);

			Delay(dl);
		}
	}
}

function void ssdremaster_deepwater_istopdown(int i, bool b)
{
	if ((i >= 0) && (i < deepWaterN))
		deepWaterStats[i][2] = b;
}

script 210 (int i, int wtag, int wtid)
{
	if ((i >= 0) && (i < deepWaterN) && (wtag > 0) && (wtid > 0))
    if (!deepWaterStats[i][1])
    {
        script210_tags[0] = wtag;
        script210_tags[1] = wtid;

        deepWaterStats[i][1]=true;
        ACS_NamedExecute("ssdremaster_deepwater_do_splash", 0, i,wtag,wtid);
    }
}

script 211 (int i)
{
	if ((i >= 0) && (i < deepWaterN))
    if (deepWaterStats[i][1])
    {
        deepWaterStats[i][1]=false;
    }
}

// water current setting

function void sdr_deepwater_set_current(int tag,int wtag, int tid0,int tid1, int sp, bool do_surface_anim, bool do_surface_rotate, bool do_current, bool use_custom_speed, bool reversed)
{
	bool current_log=false;

	if ((tag > 0) && (wtag > 0) && (tid0 > 0) && (tid1 > 0) && (sp >= 0))
	{
		int ang,len;
		int ang_temp;

		if (reversed)
		{
			int swap_temp=tid0;
			tid0 = tid1;
			tid1 = swap_temp;
		}

		ang = ssdremaster_get_facing_angle(tid0, tid1);
		len = ssdremaster_get_facing_length(tid0, tid1);

		if (current_log)
		{
			Log(s:"Current description BEGIN");

			Log(s:" Tags: ",d:tag,s:", ",d:wtag,s:" (water)");

			Log(s:" Angle: ",d:FixedMul(ang,360) >> 16);
			Log(s:" Length: ",d:len >> 16);

			Log(s:" Speed (rounded): ",d:sp >> 16);
		}

		if (do_surface_anim)
		{
			if (sp)
			{
				int x_scroll=GetActorX(tid1) - GetActorX(tid0);
				int y_scroll=GetActorY(tid1) - GetActorY(tid0);
				if (use_custom_speed)
				{
					x_scroll = FixedMul(FixedDiv(x_scroll,len),sp);
					y_scroll = FixedMul(FixedDiv(y_scroll,len),sp);
				}
				Scroll_Ceiling(wtag, x_scroll >> 16, y_scroll >> 16, SCROLL);
				if (current_log) Log(s:"Liquid Surface scrolling ON");
			}
			else
			{
				Scroll_Ceiling(wtag, 0, 0, SCROLL);
				if (current_log) Log(s:"Liquid Surface scrolling OFF");
			}
		}
		if (do_surface_rotate)
		{
			ang_temp = ang - sdr_water_current_base_dir;
			while (ang_temp < 0.0) ang_temp += 1.0;
			Sector_SetRotation(wtag, 0, FixedMul(ang_temp,360) >> 16);
			if (current_log) Log(s:"Liquid Surface rotation DONE");
		}

		if (do_current && ((len > 0) || use_custom_speed))
		{
			if (sp > 0)
			{
				int sp_temp=sp;
				if (!use_custom_speed)
					sp_temp = FixedMul(sp,len);
				ang_temp = FixedMul(ang,256 << 16);
				Sector_SetCurrent(tag, sp_temp >> 16, ang_temp >> 16, NO);
				if (current_log) Log(s:"Liquid Current ON");
			}
			else
			{
				Sector_SetCurrent(tag, 0, 0, NO);
				if (current_log) Log(s:"Liquid Current OFF");
			}
		}

		if (current_log) Log(s:"Current description END");
	}
}

// thing activation on water surfaces (e.g. ambients)

script 212 (int i, int tid, int active) // in both ways
{
	if ((i >= 0) && (i < deepWaterN) && (tid > 0))
	{
		ssdremaster_dw_act_surface[0] = true;
		ssdremaster_dw_act_surface[1] = true;

		while (!deepWaterStats[i][1]) Delay(1);
		ACS_NamedExecute("ssdremaster_deepwater_do_thing_activation", 0, i,tid,active);
	}
}

script 213 (int i, int tid, int active) // downward only
{
	if ((i >= 0) && (i < deepWaterN) && (tid > 0))
	{
		ssdremaster_dw_act_surface[0] = true;
		ssdremaster_dw_act_surface[1] = false;

		while (!deepWaterStats[i][1]) Delay(1);
		ACS_NamedExecute("ssdremaster_deepwater_do_thing_activation", 0, i,tid,active);
	}
}

script "ssdremaster_deepwater_do_thing_activation" (int i, int tid, int active_i)
{
	if ((i >= 0) && (i < deepWaterN) && (tid > 0))
	{
		int wtag=script210_tags[0];
		int wtid=script210_tags[1];

		bool active=false;
		if (active_i != 0) active=true;
		bool log_check=false;
		bool log_activation=false;

		while (deepWaterStats[i][1])
		{
			int checkVal;
			bool activated=!GetActorProperty(tid, APROP_Dormant);
			int dl=2;

			ssdremaster_dw_chk_water_id = i;

			checkVal = ssdremaster_deepwater_check(0, wtag, wtid, deepWaterStats[i][2], log_check);

			if (ssdremaster_dw_act_surface[0] && (checkVal < 0))
			{
				if (!activated && active)
				{
					if (log_activation) Log(s:"ssdremaster_deepwater_do_thing_activation: water_id = ",d:i,s:", thing tid:",d:tid,s:", activating below surface...");
					Thing_Activate(tid);
					SetActorProperty(tid, APROP_Dormant, false);
				}
				if (activated && !active)
				{
					if (log_activation) Log(s:"ssdremaster_deepwater_do_thing_activation: water_id = ",d:i,s:", thing tid:",d:tid,s:", deactivating below surface...");
					Thing_Deactivate(tid);
					SetActorProperty(tid, APROP_Dormant, true);
				}
			}
			if (ssdremaster_dw_act_surface[1] && (checkVal > 0))
			{
				if (activated && active)
				{
					if (log_activation) Log(s:"ssdremaster_deepwater_do_thing_activation: water_id = ",d:i,s:", thing tid:",d:tid,s:", deactivating above surface...");
					Thing_Deactivate(tid);
					SetActorProperty(tid, APROP_Dormant, true);
				}
				if (!activated && !active)
				{
					if (log_activation) Log(s:"ssdremaster_deepwater_do_thing_activation: water_id = ",d:i,s:", thing tid:",d:tid,s:", activating above surface...");
					Thing_Activate(tid);
					SetActorProperty(tid, APROP_Dormant, false);
				}
			}

			Delay(dl);
		}
	}
}

// actor facing functions

function int ssdremaster_get_facing_length(int tid_from, int tid_to)
{
	int x0,x1;
	int y0,y1;
	int res=0;

	if ((tid_from >= 0) && (tid_to >= 0) && (tid_from != tid_to))
	{
		x0 = GetActorX(tid_from); y0 = GetActorY(tid_from);
		x1 = GetActorX(tid_to); y1 = GetActorY(tid_to);
		res = VectorLength(x1-x0,y1-y0);
	}

	return res;
}

function int ssdremaster_get_facing_angle(int tid_from, int tid_to)
{
	int x0,x1;
	int y0,y1;
	int res=0;

	if ((tid_from >= 0) && (tid_to >= 0) && (tid_from != tid_to))
	{
		x0 = GetActorX(tid_from); y0 = GetActorY(tid_from);
		x1 = GetActorX(tid_to); y1 = GetActorY(tid_to);
		res = VectorAngle(x1-x0,y1-y0);
	}

	return res;
}

script 904 (int target_tid, int target_pitch) // generic face to actor
{
	bool facing_log=false;

	if (target_tid >= 0)
	{
		int ang0=GetActorAngle(0), ang1=ssdremaster_get_facing_angle(0, target_tid);
		int pit0=GetActorPitch(0), pit1=FixedDiv(target_pitch << 16,360 << 16);
		int i=0, ang_n=script904_ang_n;
		int dl=1;

		int fixed_n=FixedDiv(1 << 16,ang_n << 16);
		int ang_dir=1;

		int ang_d,pit_d,	ang_step,pit_step,	ang,pit;

		if (facing_log)
		{
			Log(d:ang0 >> 8,s:",",d:ang1 >> 8);
			Log(d:pit0 >> 8,s:",",d:pit1 >> 8);
		}

		ang_d = ang1-ang0, pit_d = pit1-pit0;

		ang_step = FixedMul(ang_d,fixed_n), pit_step = FixedMul(pit_d,fixed_n);

		ang = ang0, pit = pit0;

		for (i=0;i<ang_n;i++)
		{
			if (facing_log) Log(d:i,s:":",d:ang >> 8,s:",",d:pit >> 8);

			ang += ang_dir * ang_step, pit += pit_step;

			SetActorAngle(0, ang); SetActorPitch(0, pit);

			Delay(dl);
		}
	}
}

// thing-handling functions

script 228 (int tid1, int tid2, int do_deact_i) // simultaneous handling of thing activation or deactivation (ideal for ambient sound changes)
{
	bool do_deact=(do_deact_i != 0);

	if (do_deact)
	{
		Thing_Deactivate(tid1);
		Thing_Deactivate(tid2);
	}
	else
	{
		Thing_Activate(tid1);
		Thing_Activate(tid2);
	}
}

script 229 (int tid1, int tid2, int reversed_i)	// simultaneous handling of thing activation and deactivation (ideal for ambient sound changes)
{
	bool reversed=(reversed_i != 0);

	if (reversed)
	{
		Thing_Deactivate(tid1);
		Thing_Activate(tid2);
	}
	else
	{
		Thing_Activate(tid1);
		Thing_Deactivate(tid2);
	}
}

// forcefield management

script 230 (int ff_i, int test_mode_i)
{
	bool forcefield_log=false;

	if ((ff_i >= 0) && (ff_i < forceFieldN))
	{
		bool test_mode=(test_mode_i != 0);

		if (test_mode || !forceField_boolprops[ff_i][1])
		{
			int  lid     =forceField_intprops [ff_i][0];
			int  trans_am=forceField_intprops [ff_i][3];
			str  texStr  =forceField_strprops [ff_i][0];
			int  cd      =forceField_intprops [ff_i][4];
			bool hurt    =forceField_boolprops[ff_i][0];

			int  ang     =forceField_intprops [ff_i][5];
			int  f       =forceField_intprops [ff_i][6];

			int  n       =forceField_intprops [ff_i][1];
			int  anim_dl =forceField_intprops [ff_i][2];

			forceField_boolprops[ff_i][1] = true;

			if (!test_mode && hurt) ForceField();

			if (!test_mode && (ang >= 0))
			{
				if (forcefield_log) Log(s:"ForceField #",d:ff_i+1,s:" is thrusting with args (",d:ang,s:",",d:f,s:")...");

				ThrustThing(ang, f, NO, 0);
			}

			if ((n > 0) && (texStr != "-"))
			{
				int i;

				str texClr="-";
				int tr_add=NO;

				SetLineTexture(lid, SIDE_FRONT, TEXTURE_MIDDLE, texStr);
				SetLineTexture(lid, SIDE_BACK,  TEXTURE_MIDDLE, texStr);

				if ((n > 1) && (trans_am > 0))
				{
					for (i=0;i<=n;i++)
					{
						int i_fixed=FixedDiv((n-i) << 16,n << 16);
						int temp_trans=FixedMul(trans_am << 16,i_fixed) >> 16;

						if (forcefield_log)
						if (test_mode) Log(s:"ForceField #",d:ff_i,s:": ",d:i,s:" -> ",d:temp_trans);

						TranslucentLine(lid, temp_trans, tr_add);
						if (anim_dl > 0) Delay(anim_dl);
					}
				}
				else
				{
					if (anim_dl > 0) Delay(anim_dl);
				}

				SetLineTexture(lid, SIDE_FRONT, TEXTURE_MIDDLE, texClr);
				SetLineTexture(lid, SIDE_BACK,  TEXTURE_MIDDLE, texClr);
			}

			if (!test_mode && (cd > 0)) Delay(cd);

			forceField_boolprops[ff_i][1] = false;
		}
	}
}

function void clear_forcefield_entry(int ff_i)
{
	if ((ff_i >= 0) && (ff_i < forceFieldN))
	{
		int i,n;

		n = 7;
		for (i=0;i<n;i++)
			forceField_intprops [ff_i][i] = 0;
		forceField_intprops [ff_i][5] = -1;

		n = 2;
		for (i=0;i<n;i++)
			forceField_boolprops[ff_i][i] = false;

		n = 1;
		for (i=0;i<n;i++)
			forceField_strprops [ff_i][i] = "";
	}
}

function void sdr_set_forcefield_thrusting(int ff_i, int ang, int f)
{
	bool forcefield_log=false;

	if ((ff_i >= 0) && (ff_i < forceFieldN))
	if ((ang >= 0) && (f > 0))
	{
		int lid=forceField_intprops[ff_i][0];
		
		if (lid > 0)
		{
			forceField_intprops[ff_i][5] = ang;
			forceField_intprops[ff_i][6] = f;
		}

		if (forcefield_log)
			Log(s:"Thrusting successfully set up for ForceField #",d:ff_i,s:".");
	}
	else
	{
		if (forcefield_log)
			Log(s:"Failed to set up thrusting for ForceField #",d:ff_i,s:".");
	}
}

function void sdr_remove_forcefield_thrusting(int ff_i)
{
	if ((ff_i >= 0) && (ff_i < forceFieldN))
	{
		int lid=forceField_intprops[ff_i][0];
		
		if (lid > 0)
		{
			forceField_intprops[ff_i][5] = -1;
			forceField_intprops[ff_i][6] = 0;
		}
	}
}

function void ssdremaster_setup_forcefield(int ff_i, int lid, int anim_n, int anim_dl, int trans_am, str texStr, int cd, int blktype, bool hurt)
{
	bool forcefield_log=false;

	if ((ff_i >= 0) && (ff_i < forceFieldN) && (forceField_intprops[ff_i][0] == 0)
		&& (lid > 0) && (anim_n >= 0) && (anim_dl >= 0) && (anim_dl <= 8) && (trans_am >= 0)
		&& (texStr != "") && (cd >= 0) && (blktype > BLOCK_NOTHING))
	{
		forceField_intprops [ff_i][0] = lid;
		forceField_intprops [ff_i][1] = anim_n;
		forceField_intprops [ff_i][2] = anim_dl;
		forceField_intprops [ff_i][3] = trans_am;
		forceField_strprops [ff_i][0] = texStr;
		forceField_intprops [ff_i][4] = cd;
		forceField_boolprops[ff_i][0] = hurt;

		SetLineBlocking(lid, blktype);
		SetLineSpecial(lid, 226, 230,0,ff_i,NO,0);

		if (blktype == BLOCK_EVERYTHING)
			SetLineActivation(lid, SPAC_Push | SPAC_Impact);
		else
			SetLineActivation(lid, SPAC_Push);

		ACS_ExecuteAlways(230, 0, ff_i,YES,0);

		if (forcefield_log)
			Log(s:"ForceField #",d:ff_i,s:" successfully created.");
	}
	else
	{
		if (forcefield_log)
			Log(s:"Failed to create ForceField #",d:ff_i,s:".");
	}
}

function void ssdremaster_remove_forcefield(int ff_i)
{
	int lid=forceField_intprops[ff_i][0];

	if ((ff_i >= 0) && (ff_i < forceFieldN) && (lid > 0))
	{
		if (lid > 0)
		{
			SetLineBlocking(lid, BLOCK_NOTHING);
			SetLineSpecial(lid, 0, 0,0,0,0,0);
			SetLineActivation(lid, SPAC_Cross);

			clear_forcefield_entry(ff_i);
		}
	}
}

// other useful functions

// level functions

function void ssdremaster_leveldefaults(void)
{
	ssdremaster_default_sucktime = GetLevelInfo(LEVELINFO_SUCK_TIME);
	ssdremaster_lamertime_hours = ssdremaster_default_sucktime * 30;
}

function void ssdremaster_setLevelMusic(void)
{
	str level_music="";
	str music_silenced="-";

	if (StrCmp(ssdremaster_or_music_name,"") == 0)
	{
		if (bonus_stage_state == NOT_A_BONUS_STAGE)
		{
			if (endcounter < 3)
			{
				str music_zone_str="";

				level_music = "zone";

				if (zone < 10)
					music_zone_str = StrParam(s:"0",d:zone);
				else
					music_zone_str = StrParam(d:zone);

				level_music = StrParam(s:level_music,s:music_zone_str,s:"a",d:act);
			}
		}
		else
		{
			level_music = "z_bonus";
		}
	}
	else if (StrCmp(ssdremaster_or_music_name,music_silenced) == 0)
	{
		level_music = "";
	}
	else
	{
		level_music = ssdremaster_or_music_name;
	}

	SetMusic (level_music);
}

function void ssdremaster_OR_SetMusic(str musicName)
{
	bool debug_music_change=false;
	str music_silenced="-";

	if (StrCmp(ssdremaster_or_music_name,musicName) != 0)
	{
		if (StrCmp(musicName,"") == 0)
			ssdremaster_or_music_name = music_silenced;
		else
			ssdremaster_or_music_name = musicName;

		if (debug_music_change)
			Log(s:"Successfully override music settings: '",s:ssdremaster_or_music_name,s:"'.");

		ACS_NamedExecute("ssdremaster_wait_for_music_change", 0, 0,0,0);
	}
}

function void ssdremaster_OR_ClearMusic(void)
{
	ssdremaster_or_music_name = "";
	ACS_NamedExecute("ssdremaster_wait_for_music_change", 0, 0,0,0);
}

script "ssdremaster_wait_for_music_change" (void)
{
	while (ssdremaster_is_invincible) Delay(1);
	ssdremaster_setLevelMusic();
}

function int ssdremaster_levelinfo(void)
{
	int res=GetLevelInfo(LEVELINFO_LEVELNUM);

	if ((res >= 1) && (res <= 30))
	{
		zone = (res - 1) / 2 + 1;
		act = (res - 1) % 2 + 1;

		ssdremaster_level_par_time = GetLevelInfo(LEVELINFO_PAR_TIME);
		ssdremaster_par_time_reached = (ssdremaster_level_par_time <= 0);
	}
	else
	{
		zone = 0;
		act = 0;

		ssdremaster_level_par_time = 0;
		ssdremaster_par_time_reached = false;
	}

	return res;
}

// time functions

function bool checkTimeParams(int hours, int mins, int secs, int fracs,   bool maxOnly, bool useFrac)
{
	bool res=true;

	if (!maxOnly) res &= (hours >= 0);
	if (!maxOnly) res &= (mins  >= 0);
	res &= (mins  < 60);
	if (!maxOnly) res &= (secs  >= 0);
	res &= (secs  < 60);

	if (useFrac)
	{
		if (!maxOnly) res &= (fracs >= 0);
		res &= (fracs < time_running_settings[1]);
	}

	return res;
}

function int getTimestamp(int hours, int mins, int secs)
{
	int res=-1;

	if (checkTimeParams(hours, mins, secs, -1,   false, false))
		res = time_running_settings[1] * (secs + 60*(mins + 60*hours));

	return res;
}

function void setupLevelTime(int hours, int mins, int secs)
{
	int res=getTimestamp(hours, mins, secs);

	if (res >= 0)
		sdr_timestamp_level = res;
}

function void setupTime(int hours, int mins, int secs)
{
	int res=getTimestamp(hours, mins, secs);

	if (res >= 0)
		sdr_timestamp = res;
}

function void backupTime(void)
{
	if (sdr_timestamp_backup == SDR_TIMESTAMP_BACKUP_READY)
	{
		sdr_timestamp_backup = sdr_timestamp;
	}
}

function void restoreTime(void)
{
	if (sdr_timestamp_backup > 0)
	{
		sdr_timestamp = sdr_timestamp_backup;
		sdr_timestamp_backup = SDR_TIMESTAMP_BACKUP_READY;
	}
}

function bool checkTime(int hours, int mins, int secs, int fracs)
{
	bool res=true;
	bool checktime_log=false;

	res &= (checkTimeParams(hours, mins, secs, fracs,   true, true));

	if (res)
	{
		int frac_per_seconds=time_running_settings[1];
		int timestamp_temp=sdr_timestamp;
		int hours_temp, mins_temp, secs_temp, fracs_temp;

		fracs_temp = timestamp_temp % frac_per_seconds;
		timestamp_temp /= frac_per_seconds;

		secs_temp  = timestamp_temp % 60;
		timestamp_temp /= 60;

		mins_temp  = timestamp_temp % 60;
		timestamp_temp /= 60;

		hours_temp = timestamp_temp;

		if (checktime_log)
		{
			Log(s:"HH:",d:hours_temp,s:" ? ",d:hours);
			Log(s:"MM:",d:mins_temp, s:" ? ",d:mins );
			Log(s:"SS:",d:secs_temp, s:" ? ",d:secs );
			Log(s:"FS:",d:fracs_temp,s:" ? ",d:fracs);
		}

		if (res && (hours >= 0)) res &= (hours_temp == hours);
		if (res && (mins  >= 0)) res &= (mins_temp  == mins );
		if (res && (secs  >= 0)) res &= (secs_temp  == secs );
		if (res && (fracs >= 0)) res &= (fracs_temp == fracs);
	}

	return res;
}

function int querySeconds(void)
{
	int res=-1;

	if (sdr_timestamp >= 0)
	{
		res = (sdr_timestamp / time_running_settings[1]) % 60;
	}

	return res;
}

function bool checkLevelTime(int hours, int mins, int secs, int fracs)
{
	bool res=true;

	backupTime();

	sdr_timestamp = sdr_timestamp_level;

	res &= (checkTime(hours, mins, secs, fracs));

	restoreTime();

	return res;
}

function str ssdremaster_get_time_string(int timestamp)
{
	str res="";

	if (timestamp >= 0)
	{
		int frac_per_seconds=time_running_settings[1];
		int hours, mins, secs, fracs;
		int div_temp;

		div_temp = 3600 * frac_per_seconds;
		hours = timestamp / div_temp;
		timestamp -= hours * div_temp;

		div_temp = 60 * frac_per_seconds;
		mins = timestamp / div_temp;
		timestamp -= mins * div_temp;

		div_temp = frac_per_seconds;
		secs = timestamp / div_temp;
		timestamp -= secs * div_temp;

		fracs = timestamp;

		if (time_display_settings[0])
			res = StrParam(s:res,d:hours,s:":");

		if (time_display_settings[0] && (mins < 10))
			res = StrParam(s:res,s:"0",d:mins);
		else
			res = StrParam(s:res,d:mins);

		if(secs < 10)
			res = StrParam(s:res,s:":0",d:secs);
		else
			res = StrParam(s:res,s:":",d:secs);

		if (time_display_settings[1])
		{
			int frac_temp=FixedMul(FixedDiv(fracs << 16,frac_per_seconds << 16),100 << 16) >> 16;

			if(frac_temp < 10)
				res = StrParam(s:res,s:".0",d:frac_temp);
			else
				res = StrParam(s:res,s:".",d:frac_temp);
		}
	}

	return res;
}

// display functions

function void ssdremaster_display_monster_hud(void)
{
	str common_monster_tag_disp_pref="Tags for ";

	bool ssdremaster_show_monster_hud, ssdremaster_debug_monster_tags;

	ssdremaster_show_monster_hud = (GetCVar("ssdremaster_show_monster_count_hud") != 0);

	if (ssdremaster_show_monster_hud)
		ssdremaster_debug_monster_tags = (GetCVar("ssdremaster_debug_monster_tags") != 0);

	if (ssdremaster_show_monster_hud)
	{
		int hud1_x=0,hud1_y=0;
		int hud2_y=0;
		int hud3_x=0,hud3_y=0;
		str killed_str="";

		hud1_y = 0.14;
		hud2_y = hud1_y + 0.06;

		if (monsters_battle_total >= 0)
		{
			killed_str = StrParam(s:killed_str,d:(monsters_battle_total - monsters_battle_killed));
			killed_str = StrParam(s:killed_str,s:"/",d:monsters_battle_total);

			hud1_x = 0.80;
		}
		else
		{
			killed_str = StrParam(s:killed_str,d:monsters_battle_killed);

			hud1_x = 0.84;
		}

		hud3_x = hud1_x - 0.12;
		hud3_y = 0.80;

		hudmessage (s:common_monster_display_prefix; 1, 14, CR_RED, hud1_x, hud1_y, 1.0, 1.0);
		hudmessage (s:killed_str;                    1, 15, CR_TAN, 0.96,   hud1_y, 1.0, 1.0);

		if (sdr_show_overall_health)
		{
			hudmessage (s:common_sumhealth_display_prefix; 1, 16, CR_GREEN, 0.80, hud2_y, 1.0, 1.0);
			hudmessage (d:monsters_battle_overall_health;  1, 17, CR_WHITE, 0.96, hud2_y, 1.0, 1.0);
		}

		if (ssdremaster_debug_monster_tags)
		{
			str monster_tags_listed="";
			int i,n, i2;

			common_monster_tag_disp_pref = StrParam(s:common_monster_tag_disp_pref,s:common_monster_display_prefix);

			i2 = 0;
			n = monsters_battle_group_N;
			for (i=0;i<n;i++)
			{
				int tid=monsters_battle_group_tids[i];

				if (tid > 0)
				{
					if (i2 > 0)
						monster_tags_listed = StrParam(s:monster_tags_listed,s:",");

					monster_tags_listed = StrParam(s:monster_tags_listed,d:tid);

					i2++;
				}
			}

			monster_tags_listed = StrParam(s:"'",s:monster_tags_listed,s:"'");

			hudmessage (s:common_monster_tag_disp_pref; 1, 24, CR_GREEN, hud3_x, hud3_y, 0.5, 1.0);
			hudmessage (s:monster_tags_listed;          1, 25, CR_WHITE, 0.96,   hud3_y, 0.5, 1.0);
		}
	}
}

function void ssdremaster_display_target_hud(void)
{
	bool ssdremaster_show_target_hud=(GetCVar("ssdremaster_show_boss_target_hud") != 0);

	if (ssdremaster_show_target_hud)
	{
		int hud1_y=0, hud2_y=0;
		int tid;

		if (monsters_battle_state == MONSTERS_BATTLE_ENCOUNTER)
		{
			if (sdr_show_overall_health)
				hud1_y = 0.26;
			else
				hud1_y = 0.20;
		}
		else
		{
			hud1_y = 0.14;
		}

		hud2_y = hud1_y + 0.06;

		hudmessage (s:common_target_display_prefix;                      1, 11, CR_GOLD, 0.88, hud1_y, 1.0, 1.0);
		hudmessage (d:boss_target_stats[0],s:"/",d:boss_target_stats[1]; 1, 12, CR_TAN,  0.96, hud1_y, 1.0, 1.0);

		tid = boss_target_stats[2];

		if (tid > 0)
		{
			int health2=GetActorProperty(tid, APROP_Health);

			if (health2 < 0) health2 = 0;

			hudmessage (s:common_trghealth_display_prefix; 1, 21, CR_RED,   0.80, hud2_y, 1.0, 1.0);
			hudmessage (d:health2;                         1, 22, CR_WHITE, 0.96, hud2_y, 1.0, 1.0);
		}
	}
}

function void ssdremaster_display_boss_health(str boss_name, int boss_health, int boss_col)
{
	hudmessage (s:boss_name,s:": "; 1, 13, boss_col, 0.76, 0.08, 1.0, 1.0);
	hudmessage (d:boss_health;      1, 23, CR_WHITE, 0.96, 0.08, 1.0, 1.0);
}

function void ssdremaster_display_time(void)
{
	hudmessage (s:common_time_display_prefix;                        0, 10, CR_GOLD,  0.04, 0.10, 0.0);

	if (sdr_triggered_lamertime)
		hudmessage (s:"LAMER!";                                  0, 20, CR_RED,   0.20, 0.10, 0.0);
	else
		hudmessage (s:ssdremaster_get_time_string(sdr_timestamp); 0, 20, CR_WHITE, 0.20, 0.10, 0.0);
}

function void ssdremaster_clear_time(void)
{
	if (!ssdremaster_time_running)
	{
		hudmessage (s:""; 0, 10, 0, 0, 0, 0);
		hudmessage (s:""; 0, 20, 0, 0, 0, 0);
	}
}

function void ssdremaster_display_timebonus(void)
{
	if (ssdremaster_debug_timebonus)
	{
		hudmessage (s:common_timebonus_display_prefix; 0, 40, CR_GOLD, 0.04, 0.20, 0.0);
		hudmessage (d:timebonus_basic_setings[0];      0, 41, CR_TAN,  0.28, 0.20, 0.0);
	}
}

function void ssdremaster_clear_timebonus(void)
{
	if (ssdremaster_debug_timebonus)
	{
		hudmessage (s:""; 0, 40, 0, 0, 0, 0);
		hudmessage (s:""; 0, 41, 0, 0, 0, 0);
	}
}

function void ssdremaster_display_leveltime(void)
{
	if (ssdremaster_debug_timebonus)
	{
		hudmessage (s:common_leveltime_display_prefix;                  0, 42, CR_GOLD,  0.04, 0.26, 0.0);
		hudmessage (s:ssdremaster_get_time_string(sdr_timestamp_level); 0, 43, CR_WHITE, 0.28, 0.26, 0.0);
	}
}

function void ssdremaster_clear_leveltime(void)
{
	if (ssdremaster_debug_timebonus)
	{
		hudmessage (s:""; 0, 42, 0, 0, 0, 0);
		hudmessage (s:""; 0, 43, 0, 0, 0, 0);
	}
}

function void ssdremaster_display_score(void)
{
	hudmessage (s:common_score_display_prefix; 0,  9, CR_GOLD, 0.04, 0.04, 0.0);
	hudmessage (d:score;                       0, 19, CR_TAN,  0.20, 0.04, 0.0);
}

function void ssdremaster_display_ring(void)
{
	hudmessage (s:common_ring_display_prefix;  0,  9, CR_GOLD, 0.04, 0.04, 0.0);
	hudmessage (d:ringbonus_basic_settings[0]; 0, 19, CR_TAN,  0.20, 0.04, 0.0);
}

function str StrTrimmed(str s)
{
	str res=s;
	int n=StrLen(res);

	while ((n > 0) && (GetChar(res, 0) == ' '))
	{
		res = StrRight(res, n-1);
		n = StrLen(res);
	}
	while ((n > 0) && (GetChar(res, n-1) == ' '))
	{
		res = StrLeft(res, n-1);
		n = StrLen(res);
	}

	return res;
}

// nametag function and script (with CVar setting)

function str ssdremaster_common_get_nametag (void)
{
	str res="";

	if (ssdremaster_custom_nametag && (ssdremaster_playername != ""))
		res = ssdremaster_playername;
	else
		res = "DamaGe";

	return res;
}

script "ssdremaster_common_set_nametag" (void)
{
	bool nametag_log=false;
	do
	{
		int ssdremaster_custom_nametag_i=GetCVar("ssdremaster_custom_nametag");
		str new_playername=StrTrimmed(StrParam(n:1));
		bool cvar_new_val=(ssdremaster_custom_nametag_i != 0), cvar_old_val;

		cvar_old_val = ssdremaster_custom_nametag;
		ssdremaster_custom_nametag = cvar_new_val;

		if (nametag_log)
		if (cvar_new_val != cvar_old_val)
		{
			if (ssdremaster_custom_nametag)
				Log(s:"Custom nametag is ON.");
			else
				Log(s:"Custom nametag is OFF");
		}

		if (ssdremaster_custom_nametag && (new_playername != ssdremaster_playername))
		{
			ssdremaster_playername = new_playername;
			if (nametag_log) Log(s:"Nametag is: ",s:ssdremaster_playername);
		}

		if (ssdremaster_loop_nametag_change) Delay(5);
	} while (ssdremaster_loop_nametag_change);
}

// map control scripts (e.g. OPEN)

script "ssdremaster_common_init" OPEN
{
	int i, j;

	int level_num_temp=ssdremaster_levelinfo();

	ssdremaster_overall_cheats = false;

	ssdremaster_enable_keyscramble = (GetCVar("ssdremaster_enable_keyscramble"));

	ssdremaster_dw_chk_water_id = -1;

	script904_ang_n = 8;

	time_running_settings[0] = 5;
	time_running_settings[1] = 7;

	show_hud = false;

	sdr_water_current_base_dir = 0;

	story_lev_num = 0;
	bonus_lev_num = 0;

	ssdremaster_do_scoring = false;

	ssdremaster_loop_nametag_change = true;
	ACS_NamedExecute("ssdremaster_common_set_nametag", 0, 0,0,0);

	if ((level_num_temp >=  1) && (level_num_temp <= 30))
	{
		for (i=0;i<deepWaterN;i++)
			for (j=0;j<3;j++)
				deepWaterStats[i][j] = false;

		for (i=0;i<forceFieldN;i++)
			clear_forcefield_entry(i);
	}

	ssdremaster_init_random_seed(!sdr_common_init_firsttime);

	// main title
	if (level_num_temp == SDR_LEVELNUM_TITLEMAP)
	{
		story_lev_num = SDR_LEVELNUM_TITLEMAP;
		ssdremaster_is_invincible = false;
	}

	// story levels
	if ((level_num_temp >=  1) && (level_num_temp <= 30))
		story_lev_num = level_num_temp;

	// bonus levels
	if ((level_num_temp >= 31) && (level_num_temp <= 35))
		bonus_lev_num = level_num_temp - 30;

	ACS_NamedExecute("ssdremaster_create_obstacle_translations", 0, 0,0,0);
	NamedScriptWait("ssdremaster_create_obstacle_translations");

	// init translation to 'seven sinner' bosses
	if (((level_num_temp >=  1) && (level_num_temp <= 30)) || (level_num_temp == 99))
		ACS_NamedExecute("ssdremaster_init_sevensinner_translation", 0, 0,0,0);

	// story levels
	if ((level_num_temp >=  1) && (level_num_temp <= 30))
	{
		bonus_stage_state = NOT_A_BONUS_STAGE;

		endcounter = 0;

		keyscramble_translation_id = 0;

		if (!sdr_common_init_firsttime)
			keyscramble_clear_results();

		// disable 'key scramble' feature in levels where fails (temporarily!)
		if (false)
		if ((story_lev_num ==  9) || (story_lev_num == 10))
			ssdremaster_enable_keyscramble = false;

		if (true)
		if (story_lev_num == 21)
			sdr_keyscramble_pick_onlyexist = true;


		if (ssdremaster_enable_keyscramble)
		{
			if (story_lev_num ==  3) apply_keyscramble_for_stage( 2);
			if (story_lev_num ==  9) apply_keyscramble_for_stage( 8);
			if (story_lev_num == 14) apply_keyscramble_for_stage(13);
			if (story_lev_num == 16) apply_keyscramble_for_stage(15);

			if (story_lev_num ==  8) keyscramble_make_backup();

			init_keyscramble_for_stage(story_lev_num);

			apply_keyscramble_for_stage(story_lev_num);
		}

		boss_target_stats[0] = 0;

		if ((act == 2) || (level_num_temp == 29))
		{
			boss_battle_state = BOSS_BATTLE_STANDBY;
			boss_target_stats[1] = 8;

			// properties for target as actor
			boss_target_stats[2] = 0; // tid
			boss_target_stats[3] = 0; // health

			if (level_num_temp == 29)
			{
				boss_target_count_borders[15][0] = 4;
				boss_target_count_borders[15][1] = 8;
			}
		}
		else
		{
			boss_battle_state = NOT_A_BOSS_BATTLE_LEVEL;
			boss_target_stats[1] = 0;
		}

		monsters_battle_killed = 0;
		monsters_battle_total = -1;

		monsters_battle_running = 0;

		monsters_battle_state = MONSTERS_BATTLE_STANDBY;

		for (i=0;i<3;i++)
			killbonus_basic_settings[i] = 0;

		secretbonus_basic_settings[1] = 0;

		timebonus_basic_setings[0] = timebonus_per_level[level_num_temp-1];
		timebonus_basic_setings[1] = timebonus_down_per_gameskill[GameSkill()];

		ssdremaster_debug_timebonus = false;

		ssdremaster_is_invincible = false;
		ssdremaster_or_music_name = "";

		time_display_settings[0] = true;
		time_display_settings[1] = false;

		if (!sdr_common_init_firsttime)
		{
			sdr_common_init_firsttime = true;

			ssdremaster_leveldefaults();

			setupTime(00,00,00);

			sdr_timestamp_backup = SDR_TIMESTAMP_BACKUP_READY;

			ssdremaster_mock_count = 0;

			ssdremaster_game_achievements[0] = 0;

			score = 0;
		}

		ssdremaster_map_achievements[0] = 0;

		ssdremaster_achievements_looped = true;

		for (j=0;j<SDR_ACHIEVEMENT_TYPE_N;j++)
		{
			int achievements_N=0;

			switch (j)
			{
				case SDR_ACHIEVEMENT_TYPE_GAME: achievements_N = SDR_GAME_ACHIEVEMENTS_N; break;
				case SDR_ACHIEVEMENT_TYPE_MAP: achievements_N = SDR_MAP_ACHIEVEMENTS_N; break;
				default: break;
			}

			for (i=0;i<achievements_N;i++)
				ACS_NamedExecuteAlways("ssdremaster_check_achievements", 0, j,i,0);
		}

		setupLevelTime(00,00,00);

		if (level_num_temp >= 2)
		{
			TakeInventory ("BlueCard2", 1);
			TakeInventory ("RedCard2", 1);
			TakeInventory ("YellowCard2", 1);
			TakeInventory ("GreenCard", 1);
			TakeInventory ("PurpleCard", 1);
			TakeInventory ("OrangeCard", 1);

			TakeInventory ("PowerStrength", 1);
			TakeInventory ("PowerInvisibility", 1);
			TakeInventory ("PowerIronFeet", 1);
		}
	}
	// bonus levels
	if ((level_num_temp >= 31) && (level_num_temp <= 35))
	{
		bonus_stage_state = BONUS_STAGE_PLAYING;

		endcounter = 0;

		boss_battle_state = NOT_A_BOSS_BATTLE_LEVEL;

		for (i=0;i<4;i++)
			boss_target_stats[i] = 0;

		monsters_battle_state = MONSTERS_BATTLE_UNAVAILABLE;

		monsters_battle_killed = 0;
		monsters_battle_total = -1;

		time_display_settings[0] = false;
		time_display_settings[1] = true;

		backupTime();

		for (i=0;i<3;i++)
			ringbonus_basic_settings[i] = 0;

		TakeInventory ("PowerInvisibility", 1);
		TakeInventory ("PowerIronFeet", 1);

		setmusic ("z_bonus");

		SetWeapon ("Fist");

		if ((level_num_temp >= 31) && (level_num_temp <= 34))
			ACS_NamedExecute("ssdremaster_loop_ring_display", 0, 0,0,0);
	}

	// common part of all levels starting
	SetPlayerProperty (1, 0, 5);
	SetActorProperty(0, APROP_Speed, 65536);

	ready = true;

	if (((level_num_temp >=  1) && (level_num_temp <= 30)) || ((level_num_temp >= 31) && (level_num_temp <= 35)))
		while (!show_hud) Delay(1);

	// show HUD in story levels
	if ((level_num_temp >=  1) && (level_num_temp <= 30))
	{
		str title_str=zone_titles[zone-1];

		ACS_NamedExecute ("ssdremaster_loop_score_display", 0, 0, 0, 0);

		setfont ("BigFont");
		ssdremaster_display_time();
		setfont ("BigFont");
		ssdremaster_display_leveltime();
		setfont ("BigFont");
		ssdremaster_display_timebonus();
		delay(5);
		hudmessage (s:title_str; 2, 0, CR_WHITE, 0.5, 0.46, 5.0, 0.01, 1.0);
		delay(6);
		hudmessage (s:"Act   "; 2, 0, CR_BLUE, 0.5, 0.53, 4.83, 0.01, 1.0);
		hudmessage (s:StrParam(s:"     ",d:act); 2, 0, CR_WHITE, 0.5, 0.53, 4.83, 0.01, 1.0);
		delay(24);

		ACS_NamedExecute ("ssdremaster_loop_time_display", 0, 0, 0, 0);
		if (level_num_temp == 30)
			ACS_NamedExecute("ssdremaster_display_boss_targets", 0, 0,0,0);
	}
	// show HUD in bonus levels
	if ((level_num_temp >= 31) && (level_num_temp <= 35))
	{
		str title_str_prefix="Bonus Stage";

		setfont ("BigFont");
		if ((level_num_temp >= 32) && (level_num_temp <= 33))
		{
			ssdremaster_display_time();

			delay(5);
		}

		hudmessage (s:StrParam(s:title_str_prefix,s:"\cf ",d:bonus_lev_num); 2, 0, CR_WHITE, 0.5, 0.46, 3.0, 0.01, 1.0);
		delay(6);
	}
}

script "ssdremaster_show_compass" ENTER
{
	bool looped=true;

	while (!ready) Delay(1);

	if (story_lev_num == SDR_LEVELNUM_TITLEMAP)
		Terminate;

	while (!show_hud) Delay(1);

	while (looped)
	{
		bool ssdremaster_show_player_compass=(GetCVar("ssdremaster_show_player_compass") != 0);

		if (ssdremaster_show_player_compass)
		{
			int tid=0;
			int angle=(GetActorAngle(tid) >> 8);
			str angle_str="";

			if (((angle >= 0) && (angle < 16)) || ((angle >= 240) && (angle < 256)))
				angle_str = "E";
			else if ((angle >= 16) && (angle < 48))
				angle_str = "NE";		
			else if ((angle >= 48) && (angle < 80))
				angle_str = "N";
			else if ((angle >= 80) && (angle < 112))
				angle_str = "NW";
			else if ((angle >= 112) && (angle < 144))
				angle_str = "W";
			else if ((angle >= 144) && (angle < 176))
				angle_str = "SW";
			else if ((angle >= 176) && (angle < 208))
				angle_str = "S";
			else if ((angle >= 208) && (angle < 240))
				angle_str = "SE";
			else
				angle_str = "???";

			SetFont("BigFont");
			HUDMessage(s:angle_str; 1, 18, CR_WHITE, 0.80, 0.96, 1.0, 1.0);
			SetFont("SmallFont");
		}

		Delay(5);
	}
}

script "ssdremaster_common_final" UNLOADING
{
	ready = false;

	ssdremaster_time_running = false;
	ssdremaster_loop_nametag_change = false;
	ssdremaster_achievements_looped = false;
}

script "ssdremaster_common_ragequit" (int pos)
{
	bool forced=true;

	if (story_lev_num == SDR_LEVELNUM_TITLEMAP)
		Terminate;

	if (bonus_stage_state != NOT_A_BONUS_STAGE)
	{
		forced = false;

		PlaySound(0, "noway");
		SetFont("BigFont");
		HUDMessage(s:"You are leaving bonus stage without efforts."; 2, 0, CR_RED, 0.5, 0.5, 3.0, 0.01, 1.0);

		bonus_stage_state = BONUS_STAGE_LOSE;

		ACS_NamedTerminate("ssdremaster_loop_time_display", 0);
	}

	if (boss_battle_state == BOSS_BATTLE_ENCOUNTER)
	{
		boss_target_stats[0] = boss_target_stats[1];

		PlaySound(0, "noway");
		SetFont("BigFont");
		HUDMessage(s:"You are leaving boss arena without fight."; 2, 0, CR_RED, 0.5, 0.5, 3.0, 0.01, 1.0);
	}

	Delay(140);

	ACS_NamedExecute("ssdremaster_end_scoring", 0, forced,0,0);

	if (forced)
	{
		Delay(5);

		while (ssdremaster_do_scoring) delay(1);

		Exit_Normal(pos);
	}
}

script "ssdremaster_common_return" REOPEN
{
	if (bonus_stage_state == NOT_A_BONUS_STAGE)
	{
		if (story_lev_num == SDR_LEVELNUM_TITLEMAP)
			Terminate;

		ssdremaster_time_running = true;
		ACS_NamedExecute("ssdremaster_loop_time_display", 0, 0,0,0);
	}
	else
	{
		ssdremaster_time_running = false;
		ssdremaster_clear_time();
		SetPlayerProperty(1, 1, 5);
		SetFont("BigFont");
		hudmessage(s:"You've already visited this bonus stage."; 2, 0, CR_RED, 0.5, 0.45, 5.0, 0.01, 1.0);
		delay(35);
		hudmessage(s:"So you'll get lost."; 2, 0, CR_RED, 0.5, 0.55, 4.0, 0.01, 1.0);
		delay(210);
		SetPlayerProperty(1, 0, 5);
		ACS_Execute(800, 0, 0,0,0);
	}
}

//// translations

script "ssdremaster_translate_enhanced_monsters" open		// static translations

{
delay(1);
// Enhanced imp, demon, caco (zone-specific)
if (zone == 1)
	{
	
	}

if (zone == 2)
	{
	CreateTranslation (1, 64:71=156:159, 72:79=9:12);
	CreateTranslation (2, 16:31=155:159, 32:47=9:12, 79:79=12:12);
	CreateTranslation (3, 168:179=156:159, 180:191=9:12, 16:31=156:159, 32:47=9:12, 166:166=159:159, 167:167=9:9, 223:223=9:9);
	}
if (zone == 3)
	{
	CreateTranslation (1, 64:79=160:167);
	CreateTranslation (2, 16:47=160:167, 79:79=167:167);
	CreateTranslation (3, 168:191=160:167, 16:47=160:167,  166:167=163:164,  223:223=164:164);
	}
if (zone == 4)
	{
	CreateTranslation (1, 64:79=32:47);
	CreateTranslation (2, 16:47=32:47, 79:79=47:47);
	CreateTranslation (3, 168:191=32:47, 16:47=32:47, 166:167=40:41, 223:223=40:40);
	}
if (zone == 5)
	{
	CreateTranslation (1, 64:79=128:143);
	CreateTranslation (2, 16:47=128:143, 79:79=143:143);
	CreateTranslation (3, 168:191=128:143, 16:47=128:143, 166:167=136:137, 223:223=138:138);
	}
if (zone == 6)
	{
	CreateTranslation (1, 64:79=208:223);
	CreateTranslation (2, 16:47=208:223, 79:79=223:223);
	CreateTranslation (3, 168:191=208:223, 16:47=208:223, 166:167=216:217, 223:223=216:216);
	}
if (zone == 7)
	{
	CreateTranslation (1, 64:79=144:151);
	CreateTranslation (2, 16:47=64:79, 79:79=79:79);
	CreateTranslation (3, 168:191=64:79, 16:47=64:79, 166:167=72:73, 223:223=72:72);
	}
if (zone == 8)
	{
	CreateTranslation (1, 64:79=80:95);
	CreateTranslation (2, 16:47=80:95, 79:79=95:95);
	CreateTranslation (3, 168:191=80:95, 16:47=80:95, 166:167=88:89, 223:223=88:88);
	}
if (zone == 9)
	{
	CreateTranslation (1, 64:79=96:111);
	CreateTranslation (2, 16:47=96:111, 79:79=111:111);
	CreateTranslation (3, 168:191=96:111, 16:47=96:111, 166:167=104:105, 223:223=104:104);
	}
if (zone == 10)
	{
	CreateTranslation (1, 64:79=176:191);
	CreateTranslation (2, 16:47=176:191, 79:79=191:191);
	CreateTranslation (3, 168:191=176:191, 16:47=176:191, 166:167=179:180, 223:223=179:180);
	}
if (zone == 11)
	{
	CreateTranslation (1, 64:79=112:127);
	CreateTranslation (2, 16:47=112:127, 79:79=127:127);
	CreateTranslation (3, 168:191=112:127, 16:47=112:127, 166:167=120:121, 223:223=120:120);
	}
if (zone == 12)
	{
	CreateTranslation (1, 64:71=220:223, 72:76=232:234, 77:79=235:235);
	CreateTranslation (2, 16:31=220:223, 32:47=232:235, 79:79=235:235);
	CreateTranslation (3, 168:179=220:223, 180:191=232:235, 16:31=220:223, 32:47=232:235, 166:167=222:223, 168:168=232:232, 223:223=232:232);
	}
if (zone == 13)
	{
	CreateTranslation (1, 64:68=250:250, 69:71=251:251, 72:73=252:252, 74:75=253:253, 76:79=254:254);
	CreateTranslation (2, 16:25=250:250, 26:31=251:251, 32:36=252:252, 37:40=253:253, 41:48=254:254, 79:79=254:254);
	CreateTranslation (3, 168:174=250:250, 175:179=251:251, 180:182=252:252, 183:185=253:253, 186:191=254:254, 16:25=250:250, 26:31=251:251, 32:36=252:252, 37:40=253:253, 41:48=254:254, 166:167=251:252, 223:223=252:252);
	}
if (zone == 14)
	{
	CreateTranslation (1, 64:79=192:207);
	CreateTranslation (2, 16:47=192:207, 79:79=207:207);
	CreateTranslation (3, 168:191=192:207, 16:47=192:207, 166:167=200:201, 223:223=200:200);
	}
if (zone == 15)
	{
	CreateTranslation (1, 64:67=240:240, 68:76=241:246, 77:79=0:0);
	CreateTranslation (2, 16:45=240:246, 46:47=0:0, 79:79=0:0);	
	CreateTranslation (3, 168:189=240:246, 190:191=0:0, 16:45=240:246, 46:47=0:0, 166:167=243:244, 223:223=244:244);
}

// Mini cyberdemon
CreateTranslation (4, 16:31=226:231, 32:47=160:167, 168:179=226:231, 180:191=160:167, 208:215=226:231, 216:223=160:167, 232:235=164:167);

// Giant mancubus
CreateTranslation (5, 48:79=16:47, 112:127=176:191, 128:151=24:47, 1:2=46:47, 13:15=39:41, 236:239=42:45);

// Suicidal soul
CreateTranslation (6, 16:47=112:127, 160:167=112:127, 168:191=112:127, 208:223=112:127, 232:235=124:127);

// Revenant Terminator
CreateTranslation (7, 16:40=208:223, 41:47=232:235, 168:185=208:223, 186:191=232:235, 232:235=220:223, 4:4=128:128, 80:95=128:143, 209:210=129:129);

// Rail elemental
CreateTranslation (8, 160:167=192:207, 168:191=192:207, 208:223=192:207, 32:47=192:207, 232:235=203:207);

// Brawler (white)
CreateTranslation (9, 112:127=80:95, 80:95=96:111);

// Berserker (purple)
CreateTranslation (10, 112:116=250:250, 117:119=251:251, 120:121=252:252, 122:123=253:253, 124:127=254:254, 80:95=192:207);

// Chainsawer (tan)
CreateTranslation (11, 112:127=128:143, 80:95=64:79);

// Handgunner (grey)
CreateTranslation (12, 112:127=96:111, 80:81=142:143, 82:82=13:13, 83:83=236:236, 84:84=150:150, 85:85=14:14, 86:86=151:151, 87:87=237:237, 88:88=15:15, 89:91=77:79, 92:93=238:239, 94:95=1:2);

// Shotgunner (orange)
CreateTranslation (13, 112:127=208:223, 80:87=220:223, 88:95=232:235);

// Chaingunner (yellow)
CreateTranslation (14, 112:124=160:166, 125:127=167:167, 80:95=128:143);

// Supershotgunner (red)
CreateTranslation (15, 112:127=176:191, 80:95=32:47);

// Rocketeer (brown)	
CreateTranslation (16, 112:127=64:79, 80:95=144:151);

// Plasmagunner (blue)
CreateTranslation (17, 112:127=192:207, 80:92=240:246, 93:95=0:0);

// Railgunner (indigo)
CreateTranslation (18, 112:114=240:240, 115:124=241:246, 125:127=0:0, 80:84=109:111, 85:92=5:8, 93:95=0:0);

// BigFuckingGunner (green)
CreateTranslation (19, 112:127=112:127, 80:95=152:159);
}

script "ssdremaster_init_sevensinner_translation" (void)
{
	ACS_NamedExecute("ssdremaster_translate_boss_Envy", 0, 0,0,0);
	ACS_NamedExecute("ssdremaster_translate_boss_Lust", 0, 0,0,0);
	ACS_NamedExecute("ssdremaster_translate_boss_Sloth", 0, 0,0,0);
	ACS_NamedExecute("ssdremaster_translate_boss_Greed", 0, 0,0,0);
	ACS_NamedExecute("ssdremaster_translate_boss_Vanity", 0, 0,0,0);
	ACS_NamedExecute("ssdremaster_translate_boss_Gluttony", 0, 0,0,0);
	ACS_NamedExecute("ssdremaster_translate_boss_Pride", 0, 0,0,0);

	ACS_NamedExecute("ssdremaster_translate_boss_SuperMancubus", 0, 0,0,0);
	ACS_NamedExecute("ssdremaster_translate_boss_SuperSpiderdemon", 0, 0,0,0);
	ACS_NamedExecute("ssdremaster_translate_boss_SuperCyberdemon", 0, 0,0,0);

	ACS_NamedExecute("ssdremaster_translate_boss_TheFirestarter", 0, 0,0,0);
}

// boss translations

script "ssdremaster_translate_boss_Envy" (void)		// Envy	(dark green/natural green)

{
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_ENVY] = false;
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_ENVY] |= (story_lev_num == SDR_LEVELNUM_TITLEMAP);
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_ENVY] |= ((story_lev_num ==  4) || (story_lev_num == 10));

	while (ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_ENVY])
	{
	delay (3);
	CreateTranslation (20, 112:127=152:159, 152:159=128:143, 9:12=236:239);
	delay (3);
	CreateTranslation (20, 112:119=156:159, 120:127=9:12, 152:159=128:143, 9:12=236:239);
	}
}

script "ssdremaster_translate_boss_Lust" (void)		// Lust	(red/dark red)

{
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_LUST] = false;
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_LUST] |= (story_lev_num == SDR_LEVELNUM_TITLEMAP);
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_LUST] |= ((story_lev_num ==  5) || (story_lev_num ==  7) || (story_lev_num ==  8));

	while (ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_LUST])
	{
	delay (3);
	CreateTranslation (21, 112:127=176:191, 152:159=128:143, 9:12=236:239);
	delay (3);
	CreateTranslation (21, 112:127=32:47, 152:159=128:143, 9:12=236:239);
	}
}

script "ssdremaster_translate_boss_Sloth" (void)		// Sloth (brown/tan)

{
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_SLOTH] = false;
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_SLOTH] |= (story_lev_num == SDR_LEVELNUM_TITLEMAP);
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_SLOTH] |= ((story_lev_num == 13) || (story_lev_num == 14));

	while (ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_SLOTH])
	{
	delay (3);
	CreateTranslation (22, 112:127=64:79, 152:159=128:143, 9:12=236:239);
	delay (3);
	CreateTranslation (22, 112:127=128:143, 152:159=128:143, 9:12=236:239);
	}
}

script "ssdremaster_translate_boss_Greed" (void)		// 	Greed (blue/purple)

{
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_GREED] = false;
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_GREED] |= (story_lev_num == SDR_LEVELNUM_TITLEMAP);
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_GREED] |= ((story_lev_num == 15) || (story_lev_num == 16));

	while (ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_GREED])
	{
	delay (3);
	CreateTranslation (23, 112:127=192:207, 152:159=128:143, 9:12=236:239);
	delay (3);
	CreateTranslation (23, 112:127=250:254, 152:159=128:143, 9:12=236:239);
	}
}

script "ssdremaster_translate_boss_Vanity" (void)		// Vanity (grey/white)

{
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_VANITY] = false;
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_VANITY] |= (story_lev_num == SDR_LEVELNUM_TITLEMAP);
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_VANITY] |= ((story_lev_num == 17) || (story_lev_num == 20));

	while (ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_VANITY])
	{
	delay (3);
	CreateTranslation (24, 112:127=96:111, 152:159=128:143, 9:12=236:239);
	delay (3);
	CreateTranslation (24, 112:127=80:95, 152:159=128:143, 9:12=236:239);
	}
}

script "ssdremaster_translate_boss_Gluttony" (void)		// Gluttony	(orange/dark orange)

{
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_GLUTTONY] = false;
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_GLUTTONY] |= (story_lev_num == SDR_LEVELNUM_TITLEMAP);
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_GLUTTONY] |= ((story_lev_num == 23) || (story_lev_num == 24));

	while (ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_GLUTTONY])
	{
	delay (3);
	CreateTranslation (25, 112:119=220:223, 120:127=232:235, 152:159=128:143, 9:12=236:239);
	delay (3);
	CreateTranslation (25, 112:127=208:223, 152:159=128:143, 9:12=236:239);
	}
}

script "ssdremaster_translate_boss_Pride" (void)		// Pride (yellow/bright yellow)

{
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_PRIDE] = false;
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_PRIDE] |= (story_lev_num == SDR_LEVELNUM_TITLEMAP);
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_PRIDE] |= (story_lev_num == 26);

	while (ssdremaster_sevensinner_anim[SDR_SEVENSINNER_BOSS_PRIDE])
	{
	delay (3);
	CreateTranslation (26, 112:127=160:167, 152:159=128:143, 9:12=236:239);
	delay (3);
	CreateTranslation (26, 112:127=224:231, 152:159=128:143, 9:12=236:239);
	}
}

script "ssdremaster_translate_boss_SuperMancubus" (void)		// Super Mancubus

{
	delay (2);
	CreateTranslation (27, 48:79=80:111, 128:151=88:111, 16:47=0:0, 160:191=175:191, 112:127=175:191);
	delay (2);
	CreateTranslation (27, 48:79=88:111, 128:151=94:111, 16:47=0:0, 160:191=208:223, 112:127=208:223);
	delay (2);
	CreateTranslation (27, 48:79=96:111, 128:151=100:111, 16:47=0:0, 160:163=224:231, 163:167=160:167, 168:179=224:231, 180:191=160:167, 112:119=224:231, 120:127=160:167);
	delay (2);
	CreateTranslation (27, 48:79=96:111, 128:151=100:111, 16:47=0:0, 160:191=112:127, 112:127=112:127);
	delay (2);
	CreateTranslation (27, 48:79=88:111, 128:151=94:111, 16:47=0:0, 160:191=192:207, 112:127=192:207);
	delay (2);
	CreateTranslation (27, 48:79=80:111, 128:151=88:111, 16:47=0:0, 160:191=250:254, 112:127=250:254);
	Restart;
}

script "ssdremaster_translate_boss_SuperSpiderdemon" (void)		// Super Spiderdemon

{
	delay (2);
	CreateTranslation (28, 48:79=80:111, 128:151=88:111, 16:47=0:0, 160:191=175:191);
	delay (2);
	CreateTranslation (28, 48:79=88:111, 128:151=94:111, 16:47=0:0, 160:191=208:223);
	delay (2);
	CreateTranslation (28, 48:79=96:111, 128:151=100:111, 16:47=0:0, 160:163=224:231, 163:167=160:167, 168:179=224:231, 180:191=160:167);
	delay (2);
	CreateTranslation (28, 48:79=96:111, 128:151=100:111, 16:47=0:0, 160:191=112:127);
	delay (2);
	CreateTranslation (28, 48:79=88:111, 128:151=94:111, 16:47=0:0, 160:191=192:207);
	delay (2);
	CreateTranslation (28, 48:79=80:111, 128:151=88:111, 16:47=0:0, 160:191=250:254);
	Restart;
}

script "ssdremaster_translate_boss_SuperCyberdemon" (void)		// Super Cyberdemon

{
	delay (2);
	CreateTranslation (29, 48:79=80:111, 128:151=88:111, 16:47=0:0, 160:191=175:191);
	delay (2);
	CreateTranslation (29, 48:79=88:111, 128:151=94:111, 16:47=0:0, 160:191=208:223);
	delay (2);
	CreateTranslation (29, 48:79=96:111, 128:151=100:111, 16:47=0:0, 160:163=224:231, 163:167=160:167, 168:179=224:231, 180:191=160:167);
	delay (2);
	CreateTranslation (29, 48:79=96:111, 128:151=100:111, 16:47=0:0, 160:191=112:127);
	delay (2);
	CreateTranslation (29, 48:79=88:111, 128:151=94:111, 16:47=0:0, 160:191=192:207);
	delay (2);
	CreateTranslation (29, 48:79=80:111, 128:151=88:111, 16:47=0:0, 160:191=250:254);
	Restart;
}

script "ssdremaster_translate_boss_TheFirestarter" (void)		// The Firestarter

{
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_THEFIRESTARTER] = false;
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_THEFIRESTARTER] |= (story_lev_num == SDR_LEVELNUM_TITLEMAP);
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_THEFIRESTARTER] |= ((story_lev_num == 16) || (story_lev_num == 20));
	ssdremaster_sevensinner_anim[SDR_SEVENSINNER_THEFIRESTARTER] |= ((story_lev_num == 28) || (story_lev_num == 30));

	while (ssdremaster_sevensinner_anim[SDR_SEVENSINNER_THEFIRESTARTER])
	{
	delay (2);
	CreateTranslation (30, 112:127=32:47, 152:159=128:143, 9:12=236:239);
	delay (2);
	CreateTranslation (30, 112:127=169:191, 152:159=128:143, 9:12=236:239);
	delay (2);
	CreateTranslation (30, 112:119=220:223, 120:127=232:235, 152:159=128:143, 9:12=236:239);
	delay (2);
	CreateTranslation (30, 112:127=208:223, 152:159=128:143, 9:12=236:239);
	delay (2);
	CreateTranslation (30, 112:127=160:167, 152:159=128:143, 9:12=236:239);
	delay (2);
	CreateTranslation (30, 112:127=224:231, 152:159=128:143, 9:12=236:239);
	}
}

script "ssdremaster_create_obstacle_translations" (void)
{
	// copied from MAP04 script
	if (story_lev_num == 4)
	{
		CreateTranslation (45, 64:79=192:207, 151:151=240:240);
		CreateTranslation (46, 64:79=176:191, 151:151=191:191);
		CreateTranslation (47, 64:79=224:231, 151:151=231:231);
		CreateTranslation (48, 64:79=208:223, 151:151=232:232);
		CreateTranslation (49, 64:79=250:254, 151:151=254:254);
		CreateTranslation (50, 64:79=16:31, 151:151=32:32);
		CreateTranslation (51, 64:79=48:63, 151:151=64:64);
		CreateTranslation (52, 152:159=128:143, 9:12=136:143, 112:127=128:143);
		CreateTranslation (53, 152:159=80:95, 9:12=88:95);
		CreateTranslation (54, 64:79=96:111);
		CreateTranslation (55, 64:71=224:231, 72:79=160:167);
		CreateTranslation (56, 96:111=32:47, 64:79=32:47, 1:8=40:47, 236:239=44:47, 126:127=46:47);
		CreateTranslation (57, 96:111=240:247, 64:79=240:247, 1:8=244:247, 236:239=246:247, 126:127=247:247);
		CreateTranslation (58, 96:111=168:175, 64:79=168:175, 1:8=172:175, 236:239=174:175, 126:127=175:175);
		CreateTranslation (64, 225:228=169:172, 160:162=173:175);
		CreateTranslation (65, 225:228=112:115, 160:162=116:118);
		CreateTranslation (66, 225:228=192:195, 160:162=196:198);
		CreateTranslation (67, 225:228=209:213, 160:162=214:216);
		CreateTranslation (68, 225:226=250:250, 227:228=251:252, 160:162=252:254);
		CreateTranslation (69, 225:228=80:83, 160:162=84:86);
	}
	// copied from MAP05 script
	if (story_lev_num == 5)
	{
		CreateTranslation (51, 160:167=172:187);
		CreateTranslation (52, 160:167=208:223);
		CreateTranslation (53, 160:167=192:207);
		CreateTranslation (54, 112:127=208:223);
		CreateTranslation (55, 112:127=192:207);
		CreateTranslation (56, 112:127=168:183);
		CreateTranslation (57, 160:167=112:127);
		CreateTranslation (58, 168:179=224:231, 180:191=160:167, 32:39=224:231, 40:47=160:167);
		CreateTranslation (59, 152:159=208:215, 126:126=216:216, 9:12=217:220, 64:79=208:223, 128:151=208:223, 1:2=221:222, 5:8=220:223, 104:111=216:223);
		CreateTranslation (60, 168:191=208:223, 32:47=208:223);
		CreateTranslation (61, 168:188=194:207, 189:191=240:241, 32:47=192:207);
		CreateTranslation (62, 168:191=112:127, 32:47=112:127);
		CreateTranslation (63, 152:159=194:201, 126:126=202:202, 9:12=203:205, 64:75=194:207, 76:79=240:241, 128:148=194:207, 149:151=240:241, 1:1=207:207, 2:2=240:240, 5:6=206:207, 7:8=240:241, 104:109=202:207, 110:111=240:241);
		CreateTranslation (64, 160:162=250:250, 163:163=251:251, 164:164=252:252, 165:165=253:253, 166:167=254:254);
		CreateTranslation (65, 160:167=112:127);
		CreateTranslation (66, 168:179=224:231, 180:191=160:167, 32:39=224:231, 40:47=160:167, 208:223=160:163, 232:235=160:163);
		CreateTranslation (67, 168:191=250:254, 32:47=250:254, 208:223=250:254, 160:167=250:254, 232:235=254:254);
		CreateTranslation (68, 152:155=228:231, 156:159=160:163, 126:126=166:166, 9:12=164:167, 64:71=224:231, 72:79=160:167, 128:139=224:231, 140:151=160:167, 1:2=165:166, 5:8=163:167, 104:111=160:167);
		CreateTranslation (69, 152:159=250:254, 126:126=254:254, 9:9=253:253, 10:12=254:254, 64:79=250:254, 128:151=250:254, 1:2=254:254, 5:8=252:253, 99:99=250:250, 102:102=251:251, 104:111=250:251);
		CreateTranslation (70, 112:117=250:250, 118:119=251:251, 120:121=252:252, 122:123=253:253, 124:127=254:254);
		CreateTranslation (71, 112:127=160:167);
		CreateTranslation (72, 152:159=168:175, 126:126=176:176, 9:12=177:180, 64:79=168:183, 128:151=168:183, 1:2=181:182, 5:8=180:183, 104:111=176:183);
	}
	// copied from MAP06 script
	if (story_lev_num == 6)
	{
		CreateTranslation (51, 168:179=224:231, 180:191=160:167, 32:39=224:231, 40:47=160:167, 208:223=160:163, 232:235=160:163);
		CreateTranslation (52, 168:179=224:231, 180:191=160:167, 32:39=224:231, 40:47=160:167);
		CreateTranslation (53, 152:155=228:231, 156:159=160:163, 126:126=166:166, 9:12=164:167, 64:71=224:231, 72:79=160:167, 128:139=224:231, 140:151=160:167, 1:2=165:166, 5:8=163:167, 104:111=160:167);
		CreateTranslation (54, 168:191=250:254, 32:47=250:254, 208:223=250:254, 160:167=250:254, 232:235=254:254);
		CreateTranslation (55, 168:191=250:254, 168:174=250:250, 188:191=254:254, 32:47=250:254, 44:47=254:254);
		CreateTranslation (56, 152:159=250:254, 126:126=254:254, 9:9=253:253, 10:12=254:254, 64:79=250:254, 128:151=250:254, 1:2=254:254, 5:8=252:253, 99:99=250:250, 102:102=251:251, 104:111=250:251);
		CreateTranslation (57, 112:127=172:187);
		CreateTranslation (58, 112:117=250:250, 118:119=251:251, 120:121=252:252, 122:123=253:253, 124:127=254:254);
		CreateTranslation (59, 160:162=250:250, 163:163=251:251, 164:164=252:252, 165:165=253:253, 166:167=254:254);
		CreateTranslation (60, 160:167=172:187);
		CreateTranslation (61, 112:127=160:167);
		CreateTranslation (62, 152:159=168:175, 126:126=176:176, 9:12=177:180, 64:79=168:183, 128:151=168:183, 1:2=181:182, 5:8=180:183, 104:111=176:183);
		CreateTranslation (63, 168:188=194:207, 189:191=240:241, 32:47=192:207);
		CreateTranslation (64, 152:159=194:201, 126:126=202:202, 9:12=203:205, 64:75=194:207, 76:79=240:241, 128:148=194:207, 149:151=240:241, 1:1=207:207, 2:2=240:240, 5:6=206:207, 7:8=240:241, 104:109=202:207, 110:111=240:241);
		CreateTranslation (65, 168:191=112:127, 32:47=112:127);
		CreateTranslation (66, 168:191=208:223, 32:47=208:223);
		CreateTranslation (67, 152:159=208:215, 126:126=216:216, 9:12=217:220, 64:79=208:223, 128:151=208:223, 1:2=221:222, 5:8=220:223, 104:111=216:223);
		CreateTranslation (68, 112:127=208:223);
		CreateTranslation (69, 112:127=192:207);
		CreateTranslation (70, 160:167=192:207);
		CreateTranslation (71, 160:162=250:250, 163:163=251:251, 164:164=252:252, 165:165=253:253, 166:167=254:254);
		CreateTranslation (72, 160:167=208:223);
	}
	// copied from MAP07 script
	if (story_lev_num == 7)
	{
		CreateTranslation (51, 168:188=194:207, 189:191=240:241, 32:47=192:207);
		CreateTranslation (52, 112:127=160:167);
		CreateTranslation (53, 112:127=192:207);
		CreateTranslation (54, 168:179=224:231, 180:191=160:167, 32:39=224:231, 40:47=160:167, 208:223=160:163, 232:235=160:163);
		CreateTranslation (55, 168:191=250:254, 32:47=250:254, 208:223=250:254, 160:167=250:254, 232:235=254:254);
		CreateTranslation (56, 168:191=208:223, 32:47=208:223);
		CreateTranslation (57, 112:127=172:187);
		CreateTranslation (58, 112:117=250:250, 118:119=251:251, 120:121=252:252, 122:123=253:253, 124:127=254:254);
		CreateTranslation (59, 112:127=208:223);
		CreateTranslation (60, 168:191=112:127, 32:47=112:127);
	}
	// copied from MAP08 script
	if (story_lev_num == 8)
	{
		CreateTranslation (51, 168:191=208:223, 32:47=208:223);
		CreateTranslation (52, 168:188=194:207, 189:191=240:241, 32:47=192:207);
		CreateTranslation (53, 168:179=224:231, 180:191=160:167, 32:39=224:231, 40:47=160:167, 208:223=160:163, 232:235=160:163);
		CreateTranslation (54, 168:191=250:254, 32:47=250:254, 208:223=250:254, 160:167=250:254, 232:235=254:254);
		CreateTranslation (55, 168:191=112:127, 32:47=112:127);
	}
	// copied from MAP09 script
	if (story_lev_num == 9)
	{
		CreateTranslation (51, 168:179=224:231, 180:191=160:167, 32:39=224:231, 40:47=160:167, 208:223=160:163, 232:235=160:163);
		CreateTranslation (52, 168:175=224:231, 176:191=160:167, 32:39=224:231, 40:47=160:167);
		CreateTranslation (53, 152:155=228:231, 156:159=160:163, 126:126=166:166, 9:12=164:167, 64:71=224:231, 72:79=160:167, 128:139=224:231, 140:151=160:167, 1:2=165:166, 5:8=163:167, 104:111=160:167);
		CreateTranslation (54, 168:191=208:223, 32:47=208:223);
	}
	// copied from MAP12 script
	if (story_lev_num == 12)
	{
		CreateTranslation (54, 225:228=169:172, 160:162=173:175);
		CreateTranslation (55, 225:228=112:115, 160:162=116:118);
		CreateTranslation (56, 225:228=192:195, 160:162=196:198);
	}
	// copied from MAP13 script
	if (story_lev_num == 13)
	{
		CreateTranslation (61, 112:124=168:174, 125:127=175:175);
		CreateTranslation (62, 112:119=220:223, 120:124=232:234, 125:127=235:235);
		CreateTranslation (63, 112:119=156:159, 120:124=9:11, 125:127=12:12);
		CreateTranslation (64, 112:113=142:143, 114:114=13:13, 115:115=236:236, 116:116=150:150, 117:117=14:14, 118:118=151:151, 119:119=237:237, 120:120=15:15, 121:123=77:79, 124:125=238:239, 126:127=1:2);
		CreateTranslation (65, 112:127=32:47);
		CreateTranslation (66, 112:124=144:150, 125:127=151:151);
		CreateTranslation (67, 112:124=152:158, 125:127=159:159);
		CreateTranslation (54, 225:228=169:172, 160:162=173:175);
		CreateTranslation (55, 225:228=112:115, 160:162=116:118);
		CreateTranslation (56, 225:228=192:195, 160:162=196:198);
		CreateTranslation (57, 225:228=209:213, 160:162=214:216);
		CreateTranslation (58, 225:226=250:250, 227:228=251:252, 160:162=252:254);
		CreateTranslation (59, 225:228=80:83, 160:162=84:86);
		CreateTranslation (70, 192:200=169:177);
		CreateTranslation (71, 192:200=209:217);
		CreateTranslation (72, 192:198=225:231, 199:200=160:161);
		CreateTranslation (73, 192:200=112:120);
		CreateTranslation (74, 192:200=80:88);
	}
	// copied from MAP14 script
	if (story_lev_num == 14)
	{
		CreateTranslation(54, 225:228=169:172, 160:162=173:175);
		CreateTranslation(55, 225:228=112:115, 160:162=116:118);
		CreateTranslation(56, 225:228=192:195, 160:162=196:198);
		CreateTranslation(57, 225:228=209:213, 160:162=214:216);
		CreateTranslation(58, 225:226=250:250, 227:228=251:252, 160:162=252:254);
		CreateTranslation(59, 225:228=80:83, 160:162=84:86);
		CreateTranslation(60, 192:200=169:177);
		CreateTranslation(61, 192:200=209:217);
		CreateTranslation(62, 192:198=225:231, 199:200=160:161);
		CreateTranslation(63, 192:200=112:120);
		CreateTranslation(64, 192:200=80:88);
	}
	// copied from MAP15 script
	if (story_lev_num == 15)
	{
		CreateTranslation (51, 160:167=172:187);
		CreateTranslation (52, 160:167=208:223);
		CreateTranslation (53, 160:167=192:207);
		CreateTranslation (57, 160:167=112:127);
		CreateTranslation (59, 160:162=250:250, 163:163=251:251, 164:164=252:252, 165:165=253:253, 166:167=254:254);
	}
	// copied from MAP16 script
	if (story_lev_num == 16)
	{
		CreateTranslation (39, 89:95=16:16, 96:111=16:31, 123:127=27:31, 152:159=20:27, 1:3=23:23, 5:8=30:31, 64:79=16:31, 144:151=16:31, 236:239=28:31);
	}
	// copied from MAP18 script
	if (story_lev_num == 18)
	{
		CreateTranslation (59, 0:255=0:0);
	}
	// copied from MAP23 script
	if (story_lev_num == 23)
	{
		CreateTranslation(57, 225:228=209:213, 160:162=214:216);
		CreateTranslation(59, 225:228=80:83, 160:162=84:86);
	}
	// copied from MAP24 script
	if (story_lev_num == 24)
	{
		CreateTranslation(56, 225:228=192:195, 160:162=196:198);
		CreateTranslation(58, 225:226=250:250, 227:228=251:252, 160:162=252:254);
	}
	// copied from MAP27 script
	if (story_lev_num == 27)
	{
		CreateTranslation (64, 225:228=169:172, 160:162=173:175);
		CreateTranslation (65, 225:228=112:115, 160:162=116:118);
		CreateTranslation (66, 225:228=192:195, 160:162=196:198);
		CreateTranslation (55, 225:228=209:213, 160:162=214:216);
		CreateTranslation (68, 225:226=250:250, 227:228=251:252, 160:162=252:254);
	}
	// copied from MAP30 script
	if (story_lev_num == 30)
	{
		CreateTranslation (46, 112:113=142:143, 114:114=13:13, 115:115=236:236, 116:116=150:150, 117:117=14:14, 118:118=151:151, 119:119=237:237, 120:120=15:15, 121:123=77:79, 124:125=238:239, 126:127=1:2);
		CreateTranslation (47, 112:124=144:150, 125:127=151:151);
	}
	// copied from MAP31 script
	if (bonus_lev_num == 1)
	{
		CreateTranslation (54, 225:228=169:172, 160:167=173:180);
		CreateTranslation (55, 225:228=112:115, 160:167=116:123);
		CreateTranslation (56, 225:228=192:195, 160:167=196:203);
		CreateTranslation (57, 225:228=209:213, 160:167=214:221);
		CreateTranslation (58, 225:226=250:250, 227:228=251:252, 160:167=252:254);
		CreateTranslation (59, 225:228=80:83, 160:167=84:91);
	}
	// copied from MAP32 script
	if (bonus_lev_num == 2)
	{
		CreateTranslation (54, 225:228=169:172, 160:162=173:175);
		CreateTranslation (55, 225:228=112:115, 160:162=116:118);
		CreateTranslation (56, 225:228=192:195, 160:162=196:198);
		CreateTranslation (57, 225:228=209:213, 160:162=214:216);
		CreateTranslation (58, 225:226=250:250, 227:228=251:252, 160:162=252:254);
		CreateTranslation (59, 225:228=80:83, 160:162=84:86);
	}
	// copied from TITLEMAP script
	if (story_lev_num == SDR_LEVELNUM_TITLEMAP)
	{
		CreateTranslation (35, 112:119=156:159, 120:124=9:11, 125:127=12:12);
		CreateTranslation (36, 112:113=142:143, 114:114=13:13, 115:115=236:236, 116:116=150:150, 117:117=14:14, 118:118=151:151, 119:119=237:237, 120:120=15:15, 121:123=77:79, 124:125=238:239, 126:127=1:2);
		CreateTranslation (37, 112:124=144:150, 125:127=151:151);
		CreateTranslation (38, 112:124=168:174, 125:127=175:175);
		CreateTranslation (65, 225:228=112:115, 160:162=116:118);
	}
}

script "ssdremaster_use_translations" OPEN		// translation activator

{
Thing_SetTranslation (100, 1);
Thing_SetTranslation (200, 2);
Thing_SetTranslation (300, 3);
Thing_SetTranslation (400, 4);
Thing_SetTranslation (500, 5);
Thing_SetTranslation (600, 6);
Thing_SetTranslation (700, 7);
Thing_SetTranslation (800, 8);

Thing_SetTranslation (709, 9);
Thing_SetTranslation (710, 10);
Thing_SetTranslation (711, 11);
Thing_SetTranslation (712, 12);
Thing_SetTranslation (713, 13);
Thing_SetTranslation (714, 14);
Thing_SetTranslation (715, 15);
Thing_SetTranslation (716, 16);
Thing_SetTranslation (717, 17);
Thing_SetTranslation (718, 18);
Thing_SetTranslation (719, 19);
}

//// end of translations

// spawning function

function void sdr_SpawnThingToRandomDir(int spot_tid, int new_tid, int thing_sid, int speed,int vspeed, int thing_n)
{
	bool log_thing_spawn=false;

	if ((spot_tid >= 0) && (thing_sid > 0) && (new_tid >= 0))
	if ((speed >= 0) && (vspeed >= 0))
	if ((thing_n > 0) && (thing_n <= 256))
	{
		int max_ang=FixedDiv(256 << 16, thing_n << 16) >> 16;
		int min_ang=FixedDiv(max_ang << 16,2 << 16) >> 16;

		if (min_ang < 1) min_ang = 1;

		sdr_spawn_dir += Random(min_ang,max_ang);

		if (log_thing_spawn)
		{
			Log(s:"[sdr_SpawnThingToRandomDir] arguments: ",
				d:spot_tid,s:",",d:new_tid,s:",",d:thing_sid,s:",",d:speed,s:",",d:vspeed,s:",",d:thing_n);
			Log(s:"[sdr_SpawnThingToRandomDir] picked random direction: ",d:sdr_spawn_dir);
		}

		Thing_Projectile2(spot_tid, thing_sid, sdr_spawn_dir, speed,vspeed, TRUE, new_tid);
	}
}

// water splash (to be deprecated) and spring scripts

script 250 (void)					// water splash

{
activatorsound ("splash", 127);
}

script 251 (int arg0, int arg1)				// spring (horizontal)

{
str playerClassStr="DoomPlayer";
bool b=(false || checkActorClass(0, playerClassStr));

if (b)
{
activatorsound ("spring", 127);
ThrustThing (arg1, arg0, 1);
}
}

script 252 (int arg0, int arg1)				// spring (vertical)

{
str playerClassStr="DoomPlayer";
bool b=(false || checkActorClass(0, playerClassStr));

if (b)
{
activatorsound ("spring", 127);
ThrustThingZ (0, arg0, arg1, 0);
}
}

//// scripts for weapons/items

#libdefine T_BAZOOKA 170

script "ssdremaster_change_player_TID" ENTER			// player TID changer

{
Thing_ChangeTID (0, PlayerNumber()+1337);
}

script "ssdremaster_check_ammo_clip" ENTER				// clip checker

{
ammo_a[0] = CheckInventory ("Clip");

if(ammo_a[0] < capacity_a[0])
{
    setthingspecial (1020, 249, 0, 20, 0, 0);
}

if(ammo_a[0] == capacity_a[0])
{
    setthingspecial (1020, 0, 0, 0, 0, 0);
}

delay(1);
Restart;
}

script "ssdremaster_check_ammo_rockets" ENTER			// rocket checker

{
ammo_a[2] = CheckInventory ("RocketAmmo");

if(ammo_a[2] < capacity_a[2])
{
    setthingspecial (1051, 226, 249, 0, 51, 0, 0);
    setthingspecial (1055, 226, 249, 0, 55, 0, 0);
}

if(ammo_a[2] == capacity_a[2])
{
    setthingspecial (1051, 0, 0, 0, 0, 0, 0);
    setthingspecial (1055, 0, 0, 0, 0, 0, 0);
}


delay(1);
Restart;
}

script "ssdremaster_check_weapon_chainsaw" ENTER		// chainsaw checker

{
weapons_a[0] = CheckInventory ("Chainsaw");

if(weapons_a[0] == 0)
{
    setthingspecial (1001, 226, 249, 0, 1, 0, 0);
}

if(weapons_a[0] > 0)
{
    setthingspecial (1001, 0, 0, 0, 0, 0, 0);
}

delay(1);
Restart;
}

script "ssdremaster_check_weapon_pistol" ENTER			// pistol checker

{
weapons_a[1] = CheckInventory ("Pistol");
ammo_a[0] = CheckInventory ("Clip");

if(ammo_a[0] < capacity_a[0])
{
    setthingspecial (1002, 226, 249, 0, 2, 0, 0);
}

if(weapons_a[1] == 0)
if(ammo_a[0] == capacity_a[0])
{
    setthingspecial (1002, 226, 249, 0, 2, 0, 0);
}

if(weapons_a[1] > 0)
if(ammo_a[0] == capacity_a[0])
{
    setthingspecial (1002, 0, 0, 0, 0, 0, 0);
}

delay(1);
Restart;
}

script "ssdremaster_check_weapon_shotgun" ENTER			// shotgun checker

{
weapons_a[2] = CheckInventory ("Shotgun");
ammo_a[1] = CheckInventory ("Shell");

if(ammo_a[1] < capacity_a[1])
{
    setthingspecial (1003, 226, 249, 0, 3, 0, 0);
}

if(weapons_a[2] == 0)
if(ammo_a[1] == capacity_a[1])
{
    setthingspecial (1003, 226, 249, 0, 3, 0, 0);
}

if(weapons_a[2] > 0)
if(ammo_a[1] == capacity_a[1])
{
    setthingspecial (1003, 0, 0, 0, 0, 0, 0);
}

delay(1);
Restart;
}

script "ssdremaster_check_weapon_supershotgun" ENTER	// super shotgun checker

{
weapons_a[3] = CheckInventory ("SuperShotgun");
ammo_a[1] = CheckInventory ("Shell");

if(ammo_a[1] < capacity_a[1])
{
    setthingspecial (1033, 226, 249, 0, 33, 0, 0);
}

if(weapons_a[3] == 0)
if(ammo_a[1] == capacity_a[1])
{
    setthingspecial (1033, 226, 249, 0, 33, 0, 0);
}

if(weapons_a[3] > 0)
if(ammo_a[1] == capacity_a[1])
{
    setthingspecial (1033, 0, 0, 0, 0, 0, 0);
}

delay(1);
Restart;
}


script "ssdremaster_check_weapon_chaingun" ENTER		// chaingun checker

{
weapons_a[4] = CheckInventory ("Chaingun");
ammo_a[0] = CheckInventory ("Clip");

if(ammo_a[0] < capacity_a[0])
{
    setthingspecial (1004, 226, 249, 0, 4, 0, 0);
}

if(weapons_a[4] == 0)
if(ammo_a[0] == capacity_a[0])
{
    setthingspecial (1004, 226, 249, 0, 4, 0, 0);
}

if(weapons_a[4] > 0)
if(ammo_a[0] == capacity_a[0])
{
    setthingspecial (1004, 0, 0, 0, 0, 0, 0);
}

delay(1);
Restart;
}

script "ssdremaster_check_weapon_rocketlauncher" ENTER	// rocket launcher checker

{
weapons_a[5] = CheckInventory ("PhoenixRod");
ammo_a[2] = CheckInventory ("RocketAmmo");

if(ammo_a[2] < capacity_a[2])
{
    setthingspecial (1005, 226, 249, 0, 5, 0, 0);
}

if(weapons_a[5] == 0)
if(ammo_a[2] == capacity_a[2])
{
    setthingspecial (1005, 226, 249, 0, 5, 0, 0);
}

if(weapons_a[5] > 0)
if(ammo_a[2] == capacity_a[2])
{
    setthingspecial (1005, 0, 0, 0, 0, 0, 0);
}

delay(1);
Restart;
}

script "ssdremaster_check_weapon_plasmarifle" ENTER		// plasma gun checker

{
weapons_a[6] = CheckInventory ("PlasmaRifle");
ammo_a[3] = CheckInventory ("Cell");

if(ammo_a[3] < capacity_a[3])
{
    setthingspecial (1006, 226, 249, 0, 6, 0, 0);
}

if(weapons_a[6] == 0)
if(ammo_a[3] == capacity_a[3])
{
    setthingspecial (1006, 226, 249, 0, 6, 0, 0);
}

if(weapons_a[6] > 0)
if(ammo_a[3] == capacity_a[3])
{
    setthingspecial (1006, 0, 0, 0, 0, 0, 0);
}

delay(1);
Restart;
}

script "ssdremaster_check_weapon_BFG9000" ENTER			// bfg checker

{
weapons_a[7] = CheckInventory ("BFG9000");
ammo_a[3] = CheckInventory ("Cell");

if(ammo_a[3] < capacity_a[3])
{
    setthingspecial (1007, 226, 249, 0, 7, 0, 0);
}

if(weapons_a[7] == 0)
if(ammo_a[3] == capacity_a[3])
{
    setthingspecial (1007, 226, 249, 0, 7, 0, 0);
}

if(weapons_a[7] > 0)
if(ammo_a[3] == capacity_a[3])
{
    setthingspecial (1007, 0, 0, 0, 0, 0, 0);
}

delay(1);
Restart;
}

script "ssdremaster_check_weapon_railgun" ENTER			// railgun checker

{
weapons_a[8] = CheckInventory ("RocketLauncher");
ammo_a[3] = CheckInventory ("Cell");

if(ammo_a[3] < capacity_a[3])
{
    setthingspecial (1008, 226, 249, 0, 8, 0, 0);
}

if(weapons_a[8] == 0)
if(ammo_a[3] == capacity_a[3])
{
    setthingspecial (1008, 226, 249, 0, 8, 0, 0);
}

if(weapons_a[8] > 0)
if(ammo_a[3] == capacity_a[3])
{
    setthingspecial (1008, 0, 0, 0, 0, 0, 0);
}

delay(1);
Restart;
}

script "ssdremaster_check_ammo_flameorb" ENTER			// flame orb/rocket checker

{
ammo_a[2] = CheckInventory ("RocketAmmo");
ammo_a[4] = CheckInventory ("PhoenixRodAmmo");

if(ammo_a[4] < ammo_a[2])
{
    TakeInventory ("RocketAmmo", ammo_a[2] - ammo_a[4]);
}

if(ammo_a[4] > ammo_a[2])
{
    GiveInventory ("RocketAmmo", ammo_a[4] - ammo_a[2]);
}
delay(1);
Restart;
}

script 246 (void)					// ring

{
GiveInventory ("HealthBonus", 1);
}

script 247 (void)					// backpack

{

}

script "ssdremaster_check_ammo_capacity" ENTER					// capacity checker

{
pack = CheckInventory ("Backpack");

if(pack == 0)
{
    capacity_a[0] = 150;
    capacity_a[1] = 40;
    capacity_a[2] = 20;
    capacity_a[3] = 200;
}

if(pack > 0)
{
    capacity_a[0] = 300;
    capacity_a[1] = 80;
    capacity_a[2] = 40;
    capacity_a[3] = 400;
}
delay(1);
Restart;
}

script 249 (int arg0)					// grab stuff

{
if(arg0 == 1)
{
    GiveInventory ("Chainsaw", 1);
}

if(arg0 == 2)
{
    GiveInventory ("Pistol", 1);
}

if(arg0 == 20)
{
    GiveInventory ("Clip", 1);
}

if(arg0 == 3)
{
    GiveInventory ("Shotgun", 1);
}

if(arg0 == 33)
{
    GiveInventory ("SuperShotgun", 1);
}

if(arg0 == 4)
{
    GiveInventory ("Chaingun", 1);
}

if(arg0 == 5)
{
    GiveInventory ("PhoenixRod", 1);
}

if(arg0 == 51)
{
    GiveInventory ("PhoenixRodAmmo", 1);
}

if(arg0 == 55)
{
    GiveInventory ("PhoenixRodAmmo", 5);
}

if(arg0 == 6)
{
    GiveInventory ("PlasmaRifle", 1);
}

if(arg0 == 7)
{
    GiveInventory ("BFG9000", 1);
}

if(arg0 == 8)
{
    GiveInventory ("RocketLauncher", 1);
}

if(arg0 == 50)
{
GiveInventory ("ArmorBonus", (50 - armour));
}

if(arg0 == 200)
{
   GiveInventory ("HealthBonus", 50);
}

}

script "ssdremaster_check_bonus_goldenpotion" ENTER					// golden health potion checker

{
health =  CheckInventory ("Health");

if(health < 200)
{
   setthingspecial (1200, 226, 249, 0, 200, 0, 0);
}

if(health == 200)
{
   setthingspecial (1200, 0, 0, 0, 0, 0, 0);
}
delay(1);
Restart;
}

script "ssdremaster_check_lightarmour" ENTER					// light armour checker

{
armour =  CheckInventory ("Armor");

if(armour < 50)
{
   setthingspecial (1050, 226, 249, 0, 50, 0, 0);
}

if(armour > 49)
{
   setthingspecial (1050, 0, 0, 0, 0, 0, 0);
}
delay(1);
Restart;
}

//// end of weapons/items

// math functions (by tiszaszaki)

function int abs(int x)
{
	int res=x;
	if (x < 0) res = -x;
	return res;
}

function int min(int a, int b)
{
	int res=b;
	if (a < b) res = a;
	return res;
}

function int max(int a, int b)
{
	int res=b;
	if (a > b) res = a;
	return res;
}

//// SCORES.ACS

// ring functions and scripts

function bool ssdremaster_get_rings(int ring_n, int bonus_am, int max_ring_n)
{
	bool res=true;

	res &= (story_lev_num != SDR_LEVELNUM_TITLEMAP);

	if (res)
		res &= ((ring_n != 0) && (max_ring_n > 0));

	if (res)
	{
		int new_rings=ringbonus_basic_settings[0] + ring_n;

		if ((new_rings >= 0) && (new_rings <= max_ring_n))
			ringbonus_basic_settings[0] = new_rings;

		if (ring_n > 0)
			ringbonus_basic_settings[2] += bonus_am;
	}

	return res;
}

script 208 (int min_ring_n, int max_ring_n, int ring_tid) // spawn random rings around player (if possible)
{
	bool log_ring_spawn=false;

	if (((story_lev_num >=  1) && (story_lev_num <= 30)) || ((bonus_lev_num >=  1) && (bonus_lev_num <=  4)))
	if ((ssdremaster_time_running && ((bonus_lev_num >=  2) || (bonus_lev_num <=  3))) || (!ssdremaster_time_running))
	{
		if ((min_ring_n > 0) && (max_ring_n > 0) && (min_ring_n <= max_ring_n) && (ring_tid > 0))
		{
			int i,n=Random(min_ring_n,max_ring_n);
			int ringdrop_speed=(32 << 16);
			int ringdrop_pitch=FixedDiv(1 << 16,4 << 16);
			int tid=0;

			int ringdrop_hspeed, ringdrop_vspeed;

			if (log_ring_spawn) Log(s:"[cheat] Ring spawning arguments: ",d:min_ring_n,s:",",d:max_ring_n,s:",",d:ring_tid);

			sdr_spawn_dir = 0;

			ringdrop_speed = 0; ringdrop_pitch = 0; // temporarily disable speed formulas below

			if ((ringdrop_speed > 0) && (ringdrop_pitch >= 0))
			{
				ringdrop_hspeed = FixedMul(ringdrop_speed,cos(ringdrop_pitch)) >> 16;
				ringdrop_vspeed = FixedMul(ringdrop_speed,sin(ringdrop_pitch)) >> 16;
			}
			else
			{
				ringdrop_hspeed = 4;
				ringdrop_vspeed = 32;
			}

			if (log_ring_spawn) Log(s:"[cheat] Ring spawning physics: (",d:ringdrop_hspeed,s:",",d:ringdrop_vspeed,s:")");

			for (i=0;i<n;i++)
			{
				sdr_SpawnThingToRandomDir(tid, ring_tid, T_RING, ringdrop_hspeed,ringdrop_vspeed, n);

				if ((story_lev_num >=  1) && (story_lev_num <= 30))
					setthingspecial(ring_tid, 226, 246, 0, 0,0,0);

				if ((bonus_lev_num >=  1) && (bonus_lev_num <=  4))
					setthingspecial(ring_tid, 226,   3, 0, 0,0,1);

				thing_changeTID(ring_tid, 0);
			}
		}
		else
		{
			if (log_ring_spawn) Log(s:"[cheat] Invalid arguments specified for ring spawning.");
		}
	}
	else
	{
		if (log_ring_spawn) Log(s:"[cheat] Ring spawning unavaible in this level.");
	}
}

// killbonus-related functions and scripts

function void ssdremaster_inc_killtarget(void)
{
	killbonus_basic_settings[2]++;
}

function void ssdremaster_dec_killtarget(void)
{
	killbonus_basic_settings[2]--;
}

/*
script 231 (int killtarget2,int killcount2)					// killtarget checker

{
print(d:killtarget2);
delay(105);
print(d:killcount2);
}

script 232 (int killtarget2)					// killtarget

{
killtarget2++;
}
*/

script "ssdremaster_display_killbonus_info" (void)
{
	SetFont("BigFont");
	Print(s:"\c-Kills: ",d:killbonus_basic_settings[1],s:"/",d:killbonus_basic_settings[2],s:" (bonus: ",d:killbonus_basic_settings[0],s:")");
	SetFont("SmallFont");
}

script 200 (int arg0)				// scoring (kills)
{
	if ((story_lev_num >=  1) && (story_lev_num <= 29))
	{
		score+=arg0*50;
		if (story_lev_num <= 28) // not for Icon of Skin boss levels
		{
			killbonus_basic_settings[1]++;

			if(killbonus_basic_settings[1] >= killbonus_basic_settings[2])
			{
				killbonus_basic_settings[0] = 10000;
			}
		}
	}
}

script 232 (void) { ssdremaster_inc_killtarget(); }

// time manipulation functions and scripts

function bool ssdremaster_time_run_frac_sec(int fs, bool reverse)
{
	bool res=true;

	res &= ((sdr_timestamp >= 0) && ((reverse && (fs <= sdr_timestamp)) || !reverse));

	if (res)
	{
		if (reverse)
			sdr_timestamp -= fs;
		else
		{
			sdr_timestamp += fs;
			sdr_timestamp_level += fs;
		}
	}

	return res;
}

function bool ssdremaster_time_run_seconds(int s, bool reverse)
{
	return ssdremaster_time_run_frac_sec(time_running_settings[1] * s, reverse);
}

script "ssdremaster_time_warp_one_hour" (void)
{
	if (bonus_stage_state == NOT_A_BONUS_STAGE)
	{
		bool temp=ssdremaster_time_run_seconds(3600, false);
	}
}

// display-looping scripts

script "ssdremaster_loop_score_display" (void)						// score display

{
setfont ("BigFont");
ssdremaster_display_score();
delay(1);
Restart;
}

script "ssdremaster_loop_time_display" (int skipbonus, int reverse_i)			// time running and display

{
	bool reverse=(reverse_i != 0);

	ssdremaster_time_running = true;

	while (ssdremaster_time_running)
	{
		bool temp=ssdremaster_time_run_frac_sec(1, reverse);

		setfont ("BigFont");
		ssdremaster_display_time();

		if(!reverse)
		{
			setfont ("BigFont");
			ssdremaster_display_leveltime();
		}

		if(!reverse && !skipbonus && ssdremaster_par_time_reached)
		if((timebonus_basic_setings[0] != 0) && (checkLevelTime(-1,-1,-1,00)))
		{
			int timebonus_ingame_down_unit=timebonus_basic_setings[1];

			if(timebonus_basic_setings[0] < timebonus_ingame_down_unit)
				timebonus_basic_setings[0] = 0;
			else
				timebonus_basic_setings[0] -= timebonus_ingame_down_unit;		

			setfont ("BigFont");
			ssdremaster_display_timebonus();
		}

		if(!reverse && !ssdremaster_par_time_reached)
		{
			int ssdremaster_level_par_time_temp=ssdremaster_level_par_time;
			int hh,mm,ss;

			ss = ssdremaster_level_par_time_temp % 60; ssdremaster_level_par_time_temp /= 60;
			mm = ssdremaster_level_par_time_temp % 60; ssdremaster_level_par_time_temp /= 60;
			hh = ssdremaster_level_par_time_temp;

			if(checkLevelTime(hh,mm,ss,-1))
				ssdremaster_par_time_reached = true;
		}

		if(reverse && checkTime(00,00,00,00))
		{
			ssdremaster_time_running = false;
			terminate;
		}

		if(!reverse && !sdr_triggered_lamertime)
		if(checkTime(ssdremaster_lamertime_hours,-1,-1,-1))
		{
			sdr_triggered_lamertime = true;
			activatorsound ("noway", 127);
		}

		delay(time_running_settings[0]);
	}
}

// scoring and rundown scripts in story levels

// score secrets

function void ssdremaster_mock_trigger(str msg, bool fancy)
{
	bool mock_log=true;

	if (sdr_reveal_secret_message_ready)
	if (StrCmp(msg,"") != 0)
	{
		if (fancy)
		{
			SetFont("BigFont");
			hudmessage(s:msg; 2, 0, CR_GREEN, 0.5, 0.5, 3.0, 0.01, 1.0);
			SetFont("SmallFont");
		}
		else
		{
			Print(s:"\c-",s:msg);
		}

		activatorsound ("laugh", 127);
		ssdremaster_mock_count++;
	}
}

script 100 (int arg0, int arg1, int arg2)		// scoring (secrets)

{
bool sdr_debug_scoring_secrets=true;
int max_secretcount=secret_count_per_level[story_lev_num-1];

if ((arg2 >= 0) && (arg1 >= 0) && (secretbonus_basic_settings[1] < max_secretcount))
if ((story_lev_num >=  1) && (story_lev_num <= 28)) // scored in story levels preceding Final Battle Zone
{

Thing_Remove (arg0);

score+=1000;
secretbonus_basic_settings[1]++;

if(secretbonus_basic_settings[1] == max_secretcount)
	secretbonus_basic_settings[0] = 10000;

if (sdr_debug_scoring_secrets)
{
	if (secretbonus_basic_settings[1] == max_secretcount)
		Log(s:"You have revealed all secrets successfully.");
	else
		Log(s:"Secrets revealed ",d:secretbonus_basic_settings[1],s:" of ",d:max_secretcount,s:".");
}

if (arg1 != SDR_SECRET_REVEAL_NORMAL)
{
bool is_delayed_message=(arg2 != 0);

if (is_delayed_message)
{
sdr_reveal_secret_message_ready = false;

activatorsound ("secret", 127);

delay(3*35);
}

sdr_reveal_secret_message_ready = true;

switch (arg1)
{
case SDR_SECRET_REVEAL_MOCK: break; // function called instead
case SDR_SECRET_REVEAL_BONUS:
	{
		SetFont("BigFont");
		hudmessage(s:"You've found a bonus stage!"; 3, 30, CR_YELLOW, 0.5, 0.5, 0.5, 3.0);
		activatorsound ("teleport1", 127);
	}
	break;
default: break; // unknown secret type
}
}
else
{
activatorsound ("secret", 127);
}

}
}

// rundown scripts in story levels

script "ssdremaster_rundown_timebonus" (int forced_i)				// time bonus rundown

{
if(timebonus_basic_setings[0] == 0)
{
	ACS_NamedExecuteAlways ("ssdremaster_after_scoring", 0, forced_i, 0, 0);
	delay(rundown_dl);
}
else
{
	int timebonus_temp=timebonus_basic_setings[0];

	if(timebonus_basic_setings[0] <= timebonus_rundown_unit)
		timebonus_basic_setings[0] = 0;
	else
		timebonus_basic_setings[0] -= timebonus_rundown_unit;

	hudmessage (s:"time bonus:   \cc",d:timebonus_basic_setings[0]; 0, 6, CR_GOLD, 0.5, 0.47, 0.0);
	score += min(timebonus_rundown_unit,timebonus_temp);
	activatorsound ("button1", 127);
	delay(rundown_dl);
	Restart;
}
}

script "ssdremaster_rundown_killbonus" (int forced_i)				// kill bonus rundown

{
if(killbonus_basic_settings[0] == 0)
{
	ACS_NamedExecuteAlways ("ssdremaster_after_scoring", 0, forced_i, 0, 0);
	delay(rundown_dl);
}
else
{
	int killbonus_temp=killbonus_basic_settings[0];
	if (killbonus_basic_settings[0] <= killbonus_rundown_unit)
		killbonus_basic_settings[0] = 0;
	else
		killbonus_basic_settings[0] -= killbonus_rundown_unit;
	hudmessage (s:"kill bonus:   \cc",d:killbonus_basic_settings[0]; 0, 7, CR_GOLD, 0.5, 0.52, 0.0);
	score += min(killbonus_rundown_unit,killbonus_temp);
	activatorsound ("button1", 127);
	delay(rundown_dl);
	Restart;
}
}

script "ssdremaster_rundown_secretbonus" (int forced_i)				// secret bonus rundown

{
if(secretbonus_basic_settings[0] == 0)
{
	ACS_NamedExecuteAlways ("ssdremaster_after_scoring", 0, forced_i, 0, 0);
	delay(rundown_dl);
}
else
{
	int secretbonus_temp=secretbonus_basic_settings[0];
	if (secretbonus_basic_settings[0] <= secretbonus_rundown_unit)
		secretbonus_basic_settings[0] = 0;
	else
		secretbonus_basic_settings[0] -= secretbonus_rundown_unit;
	hudmessage (s:"secret bonus:   \cc",d:secretbonus_basic_settings[0]; 0, 8, CR_GOLD, 0.5, 0.57, 0.0);
	score += min(secretbonus_rundown_unit,secretbonus_temp);
	activatorsound ("button1", 127);
	delay(rundown_dl);
	Restart;
}
}

// cheat specific functions and scripts

script "ssdremaster_reward_cheater" (int reward_acs)
{
	str cheat_msg_long="However, you are a cheater!";

    if (ssdremaster_overall_cheats)
    {
		if (bonus_stage_state != NOT_A_BONUS_STAGE)
		{
			activatorsound ("noway", 127);
			SetFont("BigFont");
			hudmessage(s:cheat_msg_long; 2, 0, CR_RED, 0.5, 0.54, 2.5, 0.01, 1.0);

			if (reward_acs > 0)
				ACS_Execute(reward_acs, 0, 0,0,0);

			ssdremaster_lose_ringbonus(100);
		}
    }
}

function void ssdremaster_trigger_cheat(void)
{
	str cheat_str="Cheater!";

    if (!ssdremaster_overall_cheats)
	{
		ssdremaster_overall_cheats = true;

        Log(s:cheat_str);
	}
}

script 20 ENTER     // check for flying cheat
{
	bool flying_cheat=false;

    while (!flying_cheat && (bonus_stage_state == BONUS_STAGE_PLAYING))
    {
        bool flag_checked=CheckFlag(0, "FLOAT");

        if (flag_checked && !flying_cheat)
        {
            flying_cheat = true;

			if (bonus_lev_num != 3)
				ssdremaster_trigger_cheat();
        }

		if (!flying_cheat)
			delay(5);
    }
}

// bonus level specific functions and scripts

script "ssdremaster_bonus_level_goal_success" (int dl)
{
	setfont ("BigFont");
	activatorsound ("checkpoint", 127);
	hudmessage (s:"cool!"; 2, 0, CR_GREEN, 0.5, 0.46, 2.0, 0.01, 1.0);
	if (dl > 0)
		delay(dl);
}

script "ssdremaster_bonus_level_victory" (int dl)
{
	setfont ("BigFont");
	delay(35);
	ssdremaster_OR_SetMusic ("");
	delay(5);
	hudmessage (s:"a winner is you!"; 2, 5, CR_GREEN, 0.5, 0.46, 5.0, 0.01, 1.0);
	activatorsound ("emerald", 127);
	if (dl > 0)
		delay(dl);
}

script "ssdremaster_bonus_level_fail" (int dl)
{
	setfont ("BigFont");
	activatorsound ("noway", 127);
	hudmessage (s:"you fail it!"; 2, 1, CR_RED, 0.5, 0.46, 7.0, 0.01, 1.0);
	delay(35);
	hudmessage (s:"your skill is not enough"; 2, 2, CR_RED, 0.5, 0.51, 6.0, 0.01, 1.0);
	delay(35);
	hudmessage (s:"see you next time"; 2, 3, CR_RED, 0.5, 0.56, 5.0, 0.01, 1.0);
	delay(35);
	hudmessage (s:"bye-bye"; 2, 4, CR_RED, 0.5, 0.61, 4.0, 0.01, 1.0);
	if (dl > 0)
		delay(dl);
}

script "ssdremaster_bonus_level_goal_rings" (void)
{
	setfont ("BigFont");
	hudmessage (s:"get   \cc",s:ssdremaster_print_goal_rings(),s:"\cf   rings!"; 2, 0, CR_GOLD, 0.5, 0.46, 5.0, 0.01, 1.0);
}

function void ssdremaster_set_goal_rings(int ring_n)
{
	if (ring_n > 0)
		ringbonus_basic_settings[1] = ring_n;
}

function int ssdremaster_get_goal_rings(void)
{
	int res=-1;

	if (ringbonus_basic_settings[1] >= 0)
		res = ringbonus_basic_settings[1];

	return res;
}

function str ssdremaster_print_goal_rings(void)
{
	int res="";

	int ringcount=ringbonus_basic_settings[1];

	if (ringcount > 0)
		res = StrParam(d:ringcount);
	else if (ringcount == 0)
		res = "no";
	else
		res = "???";

	return res;
}

function bool ssdremaster_check_rings_count(bool reached)
{
	bool res=false;

	int rings=ringbonus_basic_settings[0];
	int ringcount=ringbonus_basic_settings[1];

	res |= (reached && (rings >= ringcount));
	res |= (!reached && (rings < ringcount));

	return res;
}

script "ssdremaster_lose_rings_by_mine" (int dl)
{
	if (bonus_stage_state != NOT_A_BONUS_STAGE)
	{
		activatorsound ("ringout", 127);

		if(ringbonus_basic_settings[0] < 10)
		{
			ringbonus_basic_settings[0] = 0;
			ringbonus_basic_settings[2] = 0;
		}
		else
		{
			ringbonus_basic_settings[0] -= 10;
			ringbonus_basic_settings[2] -= 1000;
			if (ringbonus_basic_settings[2] < 0) ringbonus_basic_settings[2] = 0;
		}

		if (dl > 0)
			delay(dl);
	}
}

function void ssdremaster_lose_ringbonus(int div)
{
	if (div > 0)
	if (ringbonus_basic_settings[2] > 0)
	{
		if (ringbonus_basic_settings[2] >= div)
			ringbonus_basic_settings[2] /= div;
		else
			ringbonus_basic_settings[2] = 0;
	}
}

script "ssdremaster_rundown_ringbonus" (int forced_i)				// ring bonus rundown

{
if(ringbonus_basic_settings[2] == 0)
{
	ACS_NamedExecuteAlways ("ssdremaster_after_scoring", 0, forced_i, 0, 0);
	delay(1);
	terminate;
}
else
{
	if (ringbonus_basic_settings[2] >= ringbonus_rundown_unit)
	{
		score += ringbonus_rundown_unit;
		ringbonus_basic_settings[2] -= ringbonus_rundown_unit;
	}
	else
	{
		score += ringbonus_basic_settings[2];
		ringbonus_basic_settings[2] = 0;
	}

	hudmessage (s:"ring bonus:   \cc",d:ringbonus_basic_settings[2]; 0, 6, CR_GOLD, 0.5, 0.47, 0.0);
	activatorsound ("button1", 127);
}
delay(1);
Restart;
}

script "ssdremaster_loop_ring_display" (void)					// ring display

{
setfont ("BigFont");
ssdremaster_display_ring();
delay(1);
Restart;
}

// boss related scripts and functions - seven deadly sinners

function int ssdremaster_specific_boss_tid(int boss_id)
{
	int res=0;

	if ((boss_id >= SDR_SEVENSINNER_BOSS_ENVY) && (boss_id <= SDR_SEVENSINNER_THEFIRESTARTER))
	{
		res = ssdremaster_sevensinner_tids[boss_id];

		// level specific appearance of some bosses (e.g. Vanity)
		if (boss_id == SDR_SEVENSINNER_BOSS_VANITY)
		{
			switch (story_lev_num)
			{
				case 17: res = 108; break;
				case 20: res =  63; break;
				default: break; // no other levels where Vanity appears
			}
		}
	}

	return res;
}

script "ssdremaster_show_seven_sinner_health" (int boss_id)
{
	if (!ssdremaster_boss_health_engaged)
	if ((boss_id >= SDR_SEVENSINNER_BOSS_ENVY) && (boss_id <= SDR_SEVENSINNER_THEFIRESTARTER))
	{
		str boss_name=ssdremaster_sevensinner_names[boss_id];
		int boss_tid=ssdremaster_specific_boss_tid(boss_id);

		int boss_hud_anim_i=0, boss_hud_anim_n=ssdremaster_sevensinner_colhead[boss_id][0];
		int boss_hud_anim_dl=ssdremaster_sevensinner_colhead[boss_id][1];

		if ((boss_hud_anim_n > 0) && (boss_hud_anim_dl > 0) && (boss_tid > 0))
		{
			ssdremaster_boss_health_engaged = true;

			while (ssdremaster_boss_health_engaged)
			{
				int boss_health=GetActorProperty(boss_tid, APROP_Health);
				int boss_col=ssdremaster_sevensinner_colvals[boss_id][boss_hud_anim_i];

				if (boss_health < 0) boss_health = 0;

				SetFont ("BigFont");
				ssdremaster_display_boss_health(boss_name, boss_health, boss_col);

				delay(boss_hud_anim_dl);
				boss_hud_anim_i = (boss_hud_anim_i + 1) % boss_hud_anim_n;
			}
		}
	}
}

script "ssdremaster_clear_seven_sinner_health" (void)
{
	if (ssdremaster_boss_health_engaged)
	{
		delay(35);
		ssdremaster_boss_health_engaged = false;
	}
}

script "ssdremaster_clear_seven_sinner_translation" (int boss_id)
{
	if ((boss_id >= SDR_SEVENSINNER_BOSS_ENVY) && (boss_id <= SDR_SEVENSINNER_THEFIRESTARTER))
	if (ssdremaster_sevensinner_anim[boss_id])
	{
		int boss_tid=ssdremaster_specific_boss_tid(boss_id);

		if (boss_tid > 0)
		{
			ssdremaster_sevensinner_anim[boss_id] = false;

			Delay(35);

			Thing_SetTranslation(boss_tid, -1);
		}
	}
}

script "ssdremaster_seven_sinner_death_trigger" (int boss_id, int extreme_i)
{
	bool debug_death_trigger=true;
	bool keyscramble_debug=(GetCVar("ssdremaster_debug_keyscramble") != 0);

	if ((boss_id >= SDR_SEVENSINNER_BOSS_ENVY) && (boss_id <= SDR_SEVENSINNER_THEFIRESTARTER))
	if (!ssdremaster_sevensinner_death[boss_id])
	{
		int i,n;

		int boss_tid=ssdremaster_specific_boss_tid(boss_id);
		int boss_keydrop_id=ssdremaster_sevensinner_keydrop[boss_id];
		int boss_stopacs=ssdremaster_sevensinner_stopacs[boss_id];
		int post_death_acs=ssdremaster_sevensinner_deadacs[boss_id];
		bool extreme=(extreme_i != 0);

		ssdremaster_sevensinner_death[boss_id] = true;

		if (extreme)
			ACS_NamedExecute("ssdremaster_clear_seven_sinner_translation", 0, boss_id,0,0);

		if (boss_stopacs > 0)
			ACS_Execute(boss_stopacs, 0, 0,0,0);

		if (boss_tid > 0)
		{
			if ((boss_keydrop_id >= 1) && (boss_keydrop_id <= 7))
			{
				int ssdremaster_allkeys_N=6;

				int keydrop_hspeed=8;
				int keydrop_vspeed=12;

				sdr_spawn_dir = 0;

				if (ssdremaster_enable_keyscramble)
				{
					int boss_keyscramble_idx=boss_keydrop_id-1;

					if ((boss_keyscramble_idx >= 0) && (boss_keyscramble_idx < ssdremaster_allkeys_N))
					if (keyscramble_defs_per_stage[story_lev_num-1][boss_keyscramble_idx][3] == SDR_KEYSCRAMBLE_BOSS_KEY_TID)
					{
						int random_res=keyscramble_random_results[boss_keydrop_id-1];

						if ((random_res >= 1) && (random_res <= ssdremaster_allkeys_N))
						{
							if (keyscramble_debug)
								Log(s:"[seven_sinner_death_trigger] keyscramble: ",d:boss_keydrop_id,s:" -> ",d:random_res);

							boss_keydrop_id = random_res;
						}
					}
				}

				if (boss_keydrop_id <= ssdremaster_allkeys_N)
				{
					//sdr_SpawnThingToRandomDir(boss_tid, 0, ssdremaster_allkeys[boss_keydrop_id-1], keydrop_hspeed,keydrop_vspeed, 1);
					Thing_Spawn(boss_tid, ssdremaster_allkeys[boss_keydrop_id-1], 0, 0);
				}
				else
				{
					n = ssdremaster_allkeys_N;

					for (i=0;i<n;i++)
						sdr_SpawnThingToRandomDir(boss_tid, 0, ssdremaster_allkeys[i], keydrop_hspeed,keydrop_vspeed, 1);
				}
			}

			n = 8;
			for (i=0;i<n;i++)
				Thing_ProjectileGravity (boss_tid, T_BLOODPOOL2, 32*i, 16, -1);

			delay(2);

			n = 9;
			for (i=0;i<n;i++)
			{
				Thing_ProjectileGravity (boss_tid, T_BLOODPOOL2, 0, 0, -1);
				delay(2);
			}

			Thing_ProjectileGravity (boss_tid, T_BRAINS, 0, 0, -1);

			if (post_death_acs > 0)
			{
				delay(15);

				ACS_Execute(post_death_acs, 0, 0,0,0);
			}
		}
	}
}

// boss related scripts and functions - other

script "ssdremaster_show_other_boss_health" (int boss_id, int boss_tid)
{
	if ((monsters_battle_state == MONSTERS_BATTLE_STANDBY) || (monsters_battle_state == MONSTERS_BATTLE_COMBINED))
	if ((boss_id >= SDR_OTHER_BOSS_GIANTMANCUBUS) && (boss_id <= SDR_OTHER_BOSS_SURPRISE))
	{
		str boss_name=ssdremaster_other_boss_names[boss_id];

		int boss_hud_anim_i=0, boss_hud_anim_n=ssdremaster_other_boss_colhead[boss_id][0];
		int boss_hud_anim_dl=ssdremaster_other_boss_colhead[boss_id][1];

		if ((boss_hud_anim_n > 0) && (boss_hud_anim_dl > 0) && (boss_tid > 0))
		{
			bool monster_alive=true;

			if (monsters_battle_state == MONSTERS_BATTLE_COMBINED)
			{
				monsters_battle_running++;
				while (monsters_battle_running < 2) delay(1);
			}

			monsters_battle_state = MONSTERS_BATTLE_ENCOUNTER;

			ssdremaster_other_boss_death = false;

			while ((monster_alive && (monsters_battle_state == MONSTERS_BATTLE_ENCOUNTER)) 
				|| (monsters_battle_running > 0))
			{
				int boss_health=GetActorProperty(boss_tid, APROP_Health);
				int boss_col=ssdremaster_other_boss_colvals[boss_id][boss_hud_anim_i];

				bool do_sdr_show_normal_boss_health;

				if (boss_health < 0) boss_health = 0;

				do_sdr_show_normal_boss_health = (GetCVar("ssdremaster_show_normal_boss_health") != 0);

				if (do_sdr_show_normal_boss_health)
				{
					SetFont ("BigFont");
					ssdremaster_display_boss_health(boss_name, boss_health, boss_col);
				}

				delay(boss_hud_anim_dl);
				boss_hud_anim_i = (boss_hud_anim_i + 1) % boss_hud_anim_n;

				monster_alive = (boss_health > 0);

				if (!ssdremaster_other_boss_death && !ssdremaster_other_boss_death)
				if (monsters_battle_running > 0)
				{
					ssdremaster_other_boss_death = true;
					monsters_battle_running--;
				}
			}

			monsters_battle_state = MONSTERS_BATTLE_FINALE;
		}
	}
}

function void ssdremaster_other_boss_finish(void)
{
	if (monsters_battle_state >= MONSTERS_BATTLE_ENCOUNTER)
	{
		monsters_battle_state = MONSTERS_BATTLE_STANDBY;
	}
}

// boss related scripts and functions - target-based

function void ssdremaster_set_target_tid(int tid)
{
	if (tid > 0)
	{
		boss_target_stats[2] = tid;
	}
}

function void ssdremaster_clr_target_tid(void)
{
	int tid=boss_target_stats[2];

	if (tid > 0)
	{
		boss_target_stats[2] = 0;
	}
}

function void ssdremaster_init_target_health(int health2)
{
	if (health2 > 0)
	{
		boss_target_stats[3] = health2;
	}
}

function void ssdremaster_apply_target_health(void)
{
	int tid=    boss_target_stats[2];
	int health2=boss_target_stats[3];

	if ((tid > 0) && (health2 > 0))
	{
		SetActorProperty(tid, APROP_Health, health2);
	}
}

function void ssdremaster_create_boss_target(int spot_tid, int thing_tid, int health2, int hit_acs, int hit_arg0,int hit_arg1,int hit_arg2)
{
	if ((spot_tid > 0) && (thing_tid > 0) && (health2 >= 0) && (hit_acs > 0))
	{
		spawnspot("SSDBossTarget", spot_tid, thing_tid);
		setthingspecial(thing_tid, 80, hit_acs,0,hit_arg0,hit_arg1,hit_arg2);

		ssdremaster_set_target_tid(thing_tid);
		ssdremaster_init_target_health(health2);
		ssdremaster_apply_target_health();
	}
}

function void ssdremaster_destroy_boss_target(void)
{
	int thing_tid=boss_target_stats[2];

	ssdremaster_clr_target_tid();
	if (ThingCount(0, thing_tid) > 0)
		thing_remove(thing_tid);
}

function void ssdremaster_inc_boss_target_hit(void)
{
	boss_target_stats[0]++;
}

function int ssdremaster_get_boss_target_hit(void)
{
	return boss_target_stats[0];
}

function int ssdremaster_get_boss_target_max(void)
{
	return boss_target_stats[1];
}

script "ssdremaster_query_boss_target_num" (void)
{
	bool boss_battle_level=(boss_battle_state != NOT_A_BOSS_BATTLE_LEVEL);

	if (boss_battle_level)
		Log(d:boss_target_stats[1]);
}

script "ssdremaster_ease_boss_targets" (int minimal_i)		// half boss hit count (if possible)
{
	if (boss_battle_state != NOT_A_BOSS_BATTLE_LEVEL)
	if (boss_battle_state == BOSS_BATTLE_STANDBY)
	{
		bool minimal=(minimal_i != 0);

		int new_hit_count=boss_target_stats[1] / 2;
		int boss_target_min_temp=boss_target_count_borders[zone-1][0];
		int min_hit_count=(boss_target_stats[0] + boss_target_min_temp);

		if (min_hit_count < boss_target_min_temp)
			min_hit_count = boss_target_min_temp;

		if (minimal)
		{
			boss_target_stats[1] = min_hit_count;
		}
		else
		{
			if (new_hit_count >= min_hit_count)
				boss_target_stats[1] = new_hit_count;
		}
	}
}

script "ssdremaster_harden_boss_targets" (int maximal_i)		// double boss hit count (if possible)
{
	if (boss_battle_state != NOT_A_BOSS_BATTLE_LEVEL)
	if (boss_battle_state == BOSS_BATTLE_STANDBY)
	{
		bool maximal=(maximal_i != 0);

		int new_hit_count=boss_target_stats[1] * 2;
		int boss_target_max_temp=boss_target_count_borders[zone-1][1];
		int max_hit_count=boss_target_max_temp;

		if (maximal)
		{
			boss_target_stats[1] = max_hit_count;
		}
		else
		{
			if (new_hit_count <= max_hit_count)
				boss_target_stats[1] = new_hit_count;
		}
	}
}

script "ssdremaster_display_boss_targets" (void)		// target hit display
{
	if (boss_battle_state == BOSS_BATTLE_STANDBY)
	{
		boss_battle_state = BOSS_BATTLE_ENCOUNTER;
		ACS_NamedExecute("ssdremaster_display_boss_target_loop", 0, 0,0,0);
	}
}

script "ssdremaster_display_boss_target_loop" (void)	// target hit display (looped function)
{
	setfont ("BigFont");
	ssdremaster_display_target_hud();
	delay(1);
	Restart;
}

// boss related scripts and functions - monster-based

function void ssdremaster_setCommonMonsterTag(str new_tag)
{
	common_monster_display_prefix = StrParam(s:StrTrimmed(new_tag),s:":");
}

function void ssdremaster_defCommonMonsterTag(void)
{
	common_monster_display_prefix = common_monster_disp_pref_def;
}

function int getMonstersCount(bool force_monster_hate)
{
	bool hate_debug=false;
	int thing_hate_interval=monsters_battle_hate_intval[GameSkill()];

	int res=-1;

	if ((monsters_battle_state >= MONSTERS_BATTLE_COMBINED) && (thing_hate_interval >= 0))
	{
		int i,n;
		int temp;

		res = 0;

		if (monsters_battle_icon_of_sin)
		{
			n = monsters_battle_ios_spawn_N;

			for (i=0;i<n;i++)
			{
				int monster_sid=monsters_battle_ios_spawn_IDs[i];

				if (monster_sid > 0)
				{
					temp = ThingCount(monster_sid, 0);

					res += temp;
				}
			}
		}
		else
		{
			n = monsters_battle_group_N;

			monsters_battle_overall_health = 0;

			for (i=0;i<n;i++)
			{
				int monster_tid=monsters_battle_group_tids[i];

				if (monster_tid > 0)
				{
					int secs=querySeconds();
					int prop=0;

					temp = ThingCount(0, monster_tid);
					prop = GetActorProperty(monster_tid, APROP_Health);

					if (prop < 0) prop = 0;

					monsters_battle_overall_health += temp * prop;

					if (force_monster_hate && (thing_hate_interval > 0) && (temp > 0) && (checkTime(-1,-1,-1,00)) && (secs >= 0) && ((secs % thing_hate_interval) == 0))
					{
						if (hate_debug)
							Log(s:"[getMonstersCount] forcing monsters (tag ",d:monster_tid,s:") hate player...");
						Thing_Hate(monster_tid, 0, 0);
					}

					res += temp;
				}
			}

			if ((monsters_battle_total >= 0) && (res > monsters_battle_total)) // recount total monsters when summoned by player (not for unlimited)
				monsters_battle_total = res;
		}
	}

	return res;
}

function bool checkMonstersCount(bool ignore_value)
{
	bool res=true;

	res &= (monsters_battle_state >= MONSTERS_BATTLE_ENCOUNTER);
	if (res) 
	{
		int count=getMonstersCount(TRUE);

		monsters_battle_killed = count;

		if (!ssdremaster_monster_battle_cd && (count == 0))
		if (monsters_battle_running > 0)
		{
			ssdremaster_monster_battle_cd = true;

			monsters_battle_running--;
		}

		res &= (ignore_value || (count > 0));
	}

	return res;
}

function void ssdremaster_setupMonstersBattle(int tid1, int tid2, int tid3, bool unlimited)
{
	if ((monsters_battle_state == MONSTERS_BATTLE_STANDBY) || (monsters_battle_state == MONSTERS_BATTLE_COMBINED))
	{
		monsters_battle_icon_of_sin = (unlimited && (tid1 == 6) && (tid2 == 6) && (tid3 == 6));

		monsters_battle_group_tids[0] = tid1;
		monsters_battle_group_tids[1] = tid2;
		monsters_battle_group_tids[2] = tid3;

		if (monsters_battle_state == MONSTERS_BATTLE_STANDBY)
			monsters_battle_state = MONSTERS_BATTLE_READY;

		if (!unlimited) monsters_battle_total = getMonstersCount(FALSE);
	}
}

script "ssdremaster_display_monster_hud_loop" (void)
{
	while (monsters_battle_state == MONSTERS_BATTLE_ENCOUNTER)
	{
		SetFont("BigFont");
		ssdremaster_display_monster_hud();
		delay(1);
		Restart;
	}
}

script "ssdremaster_encounterMonstersBattle" (int ended_manually_i)
{
	if ((monsters_battle_state == MONSTERS_BATTLE_READY) || (monsters_battle_state == MONSTERS_BATTLE_COMBINED))
	{
		bool loop=true;
		bool ended_manually=(ended_manually_i != 0);

		if (monsters_battle_state == MONSTERS_BATTLE_COMBINED)
		{
			monsters_battle_running++;
			while (monsters_battle_running < 2) delay(1);
		}

		monsters_battle_state = MONSTERS_BATTLE_ENCOUNTER;

		ssdremaster_monster_battle_cd = false;

		ACS_NamedExecute("ssdremaster_display_monster_hud_loop", 0, 0,0,0);

		while (loop)
		{
			loop = true;
			loop &= (monsters_battle_state == MONSTERS_BATTLE_ENCOUNTER);
			loop &= (checkMonstersCount(ended_manually));
			loop |= (monsters_battle_running > 0);
			delay(1);
		}

		delay(35);

		monsters_battle_state = MONSTERS_BATTLE_FINALE;
	}
}

function void ssdremaster_clearMonstersBattle(void)
{
	if (monsters_battle_state >= MONSTERS_BATTLE_ENCOUNTER)
	{
		int i,n=monsters_battle_group_N;

		monsters_battle_state = MONSTERS_BATTLE_STANDBY;

		for (i=0;i<n;i++)
			monsters_battle_group_tids[0] = 0;

		monsters_battle_killed = 0;
		monsters_battle_total = -1;
	}
}

function void ssdremaster_combineBattles(void)
{
	if (monsters_battle_state == MONSTERS_BATTLE_STANDBY)
		monsters_battle_state = MONSTERS_BATTLE_COMBINED;
}

// monitor powerup scripts

script 201 (int arg0, int arg1)				// health monitor

{
if (story_lev_num == SDR_LEVELNUM_TITLEMAP)
	Terminate;
Thing_Remove (arg0);
activatorsound ("monitor", 127);
delay(35);
GiveInventory ("HealthBonus", 10);
activatorsound ("ring", 127);
if (arg1 > 0) // post pickup trigger
ACS_Execute(arg1, 0, 0,0,0);
}

script 202 (int arg0, int arg1)				// armour monitor

{
if (story_lev_num == SDR_LEVELNUM_TITLEMAP)
	Terminate;
Thing_Remove (arg0);
activatorsound ("monitor", 127);
delay(35);
GiveInventory ("ArmorBonus", 10);
activatorsound ("ishield", 127);
if (arg1 > 0) // post pickup trigger
ACS_Execute(arg1, 0, 0,0,0);
}

script 203 (int arg0)	// invincibility monitor 

{
if (bonus_stage_state == NOT_A_BONUS_STAGE)
if (story_lev_num != SDR_LEVELNUM_TITLEMAP)
{
	ssdremaster_is_invincible = true;
	Thing_Remove (arg0); 
	activatorsound ("monitor", 127); 
	delay(5); 
	ACS_NamedExecute("ssdremaster_wait_for_music_change", 0, 0,0,0);
	SetMusic ("z_invuln");
	delay(30);
	SetPlayerProperty (1, 2, 5); 
	ACS_ExecuteAlways (209, 0, 776, 0, 0); 
	delay(3); 
	ACS_ExecuteAlways (209, 0, 777, 0, 0); 
	delay(3); 
	ACS_ExecuteAlways (209, 0, 778, 0, 0);
	delay(3); 
	ACS_ExecuteAlways (209, 0, 779, 0, 0); 
	delay(3); 
	ACS_ExecuteAlways (209, 0, 780, 0, 0);
	delay(700);
	sethudsize (0, 0, 0);
	SetPlayerProperty (1, 0, 5);
	ssdremaster_is_invincible = false;
}
}

script 209 (int arg0)

{
if (story_lev_num == SDR_LEVELNUM_TITLEMAP)
	Terminate;

int i;

str frames[14];// = {"1", "2", "3", "4", "5", "6", "7", "6", "5", "4", "3", "2", "1", "0"};

for (i=0;i<14;i++)
{
	int e=(7 - abs(i - 6));
	frames[i] = StrParam(d:e);
}

for(int time = 0; time < 50; time++)
{
sethudsize (512, 384, 0);
setfont ("Stars"); 
int x = random(48, 208) * 2.0, y = random(24, 128) * 2.0;
for(int stars = 0; stars < 14; stars++) 
{ 
hudmessage(s:frames[stars]; 0, arg0, -1, x, y, 0.02); 
delay(1); 
}
}
}

script 204 (int arg0, int arg1)				// invisibility monitor

{
if (story_lev_num == SDR_LEVELNUM_TITLEMAP)
	Terminate;
Thing_Remove (arg0);
activatorsound ("monitor", 127);
delay(35);
GiveInventory ("BlurSphere", 1);
activatorsound ("bshield", 127);
if (arg1 > 0) // post pickup trigger
ACS_Execute(arg1, 0, 0,0,0);
}

script 205 (int arg0, int arg1, int arg2)				// rad monitor

{
if (story_lev_num == SDR_LEVELNUM_TITLEMAP)
	Terminate;

Thing_Remove (arg0);
activatorsound ("monitor", 127);
delay(35);
GiveInventory ("RadSuit", 1);
activatorsound ("wshield", 127);
if (arg1 > 0) // post pickup trigger
ACS_Execute(arg1, 0, 0,0,0);
}

script 206 (int arg0, int arg1)				// extra life monitor

{
if (story_lev_num == SDR_LEVELNUM_TITLEMAP)
	Terminate;
Thing_Remove (arg0);
activatorsound ("monitor", 127);
delay(35);
GiveInventory ("Megasphere", 1);
activatorsound ("powerup", 127);
if (arg1 > 0) // post pickup trigger
ACS_Execute(arg1, 0, 0,0,0);
}

script 207 (int arg0)				// speed monitor

{
if (story_lev_num == SDR_LEVELNUM_TITLEMAP)
	Terminate;
Thing_Remove (arg0);
activatorsound ("monitor", 127);
delay(35);
activatorsound ("speedon", 127);
SetActorProperty(0, APROP_Speed, GetActorProperty(0, APROP_Speed) * 2); 
delay(1050);
activatorsound ("speedoff", 127);
SetActorProperty(0, APROP_Speed, GetActorProperty(0, APROP_Speed) / 2);
}

// end-of-act scripts

script "ssdremaster_stop_displaying_boss_targets" (void)		// for map 29-30 only
{
	bool boss_battle_level=(boss_battle_state != NOT_A_BOSS_BATTLE_LEVEL);

	if (boss_battle_level)
	{
		ACS_NamedTerminate ("ssdremaster_display_boss_target_loop", 0);
	}
}

script "ssdremaster_end_scoring" (int forced_i)
{
bool forced=(forced_i != 0);

ssdremaster_achievements_looped = false;

if (forced)
	ssdremaster_do_scoring = true;

if (bonus_stage_state == NOT_A_BONUS_STAGE)
{
ACS_Terminate ("ssdremaster_loop_time_display", 0);
if (boss_battle_state == BOSS_BATTLE_ENCOUNTER)
{
	boss_battle_state = BOSS_BATTLE_FINALE;
	ACS_NamedTerminate ("ssdremaster_display_boss_target_loop", 0);
}
SetPlayerProperty (1, 1, 4);
SetPlayerProperty (1, 2, 5);
SetWeapon ("Fist");
ssdremaster_OR_SetMusic ("");
delay(105);
SetMusic ("z_inter");

ssdremaster_clear_timebonus();
ssdremaster_clear_leveltime();

setfont ("BigFont");
if (ssdremaster_custom_nametag)
{
hudmessage (s:ssdremaster_playername,s:" got"; 0, 3, CR_WHITE, 0.5, 0.32, 0.0);
}
else
{
hudmessage (s:"\cdDamaGe \cjgot"; 0, 3, CR_WHITE, 0.5, 0.32, 0.0);
}
hudmessage (s:"through act ",d:act,s:" "; 0, 5, CR_WHITE, 0.5, 0.37, 0.0);
setfont ("SmallFont");
delay(35);
hudmessage (s:"time bonus:   \cc",d:timebonus_basic_setings[0]; 0, 6, CR_GOLD, 0.5, 0.47, 0.0);
delay(35);
hudmessage (s:"kill bonus:   \cc",d:killbonus_basic_settings[0]; 0, 7, CR_GOLD, 0.5, 0.52, 0.0);
delay(35);
hudmessage (s:"secret bonus:   \cc",d:secretbonus_basic_settings[0]; 0, 8, CR_GOLD, 0.5, 0.57, 0.0);
delay(55);
SetMusic ("");
delay(35);
ACS_NamedExecute ("ssdremaster_rundown_timebonus", 0, forced_i, 0, 0);
ACS_NamedExecute ("ssdremaster_rundown_killbonus", 0, forced_i, 0, 0);
ACS_NamedExecute ("ssdremaster_rundown_secretbonus", 0, forced_i, 0, 0);
}
if ((bonus_stage_state == BONUS_STAGE_WIN) || (bonus_stage_state == BONUS_STAGE_LOSE))
{
ACS_NamedTerminate ("ssdremaster_loop_ring_display", 0);
ACS_NamedExecute ("ssdremaster_loop_score_display", 0, 0, 0, 0);
ssdremaster_OR_SetMusic ("");
delay(105);
SetMusic ("z_inter");
setfont ("BigFont");
hudmessage (s:"bonus stage ",d:bonus_lev_num; 0, 3, CR_WHITE, 0.5, 0.32, 0.0);
setfont ("SmallFont");
delay(35);
hudmessage (s:"ring bonus:   \cc",d:ringbonus_basic_settings[2]; 0, 6, CR_GOLD, 0.5, 0.47, 0.0);
delay(125);
SetMusic ("");
delay(35);
ACS_NamedExecute ("ssdremaster_rundown_ringbonus", 0, 0, 0, 0);
}
}

function str ssdremaster_achievement_to_str(int type_id, int id)
{
	str res="";

	switch (type_id)
	{
		case SDR_ACHIEVEMENT_TYPE_GAME:
		{
			switch (id)
			{
				case SDR_GAME_ACHIEVEMENT_ALL_MOCKS: res = "???"; break;
				default: break;
			}
		} break;
		case SDR_ACHIEVEMENT_TYPE_MAP:
		{
			switch (id)
			{
				case SDR_MAP_ACHIEVEMENT_PERFECT: res = "PERFECT!"; break;
				default: break;
			}
		} break;
		default: break;
	}

	return res;
}

script "ssdremaster_after_scoring" (int forced_i)
{
	bool forced=(forced_i != 0);
	bool counter_ended=false;

	int n;

	if (bonus_stage_state == NOT_A_BONUS_STAGE)
	{
		endcounter++;
		if (endcounter == 3)
		{
			bool boss_battle_level=(boss_battle_state != NOT_A_BOSS_BATTLE_LEVEL);
			ambientsound ("endofact", 127);
			delay(105);
			hudmessage (s:""; 0, 3, 0, 0, 0, 0);
			hudmessage (s:""; 0, 5, 0, 0, 0, 0);
			hudmessage (s:""; 0, 6, 0, 0, 0, 0);
			hudmessage (s:""; 0, 7, 0, 0, 0, 0);
			hudmessage (s:""; 0, 8, 0, 0, 0, 0);

			n = ssdremaster_map_achievements[0];
			if (false && (n > 0))
			{
				int picked_id=ssdremaster_map_achievements[Random(0,n-1)];
				str achievement_str=ssdremaster_achievement_to_str(SDR_ACHIEVEMENT_TYPE_MAP,picked_id);

				PlaySound(0, "powerup");
				HUDMessage(s:achievement_str; 1, 0, CR_GREEN, 0.5, 0.5, 5.0, 1.0);
				Delay(210);
			}

			SetPlayerProperty (1, 0, 4);
			SetPlayerProperty (1, 0, 5);

			counter_ended = true;
		}
	}

	if ((bonus_stage_state == BONUS_STAGE_WIN) || (bonus_stage_state == BONUS_STAGE_LOSE))
	{
		endcounter++;
		if (endcounter == 1)
		{
			ambientsound ("endofact", 127);
			delay(105);
			hudmessage (s:""; 0, 3, 0, 0, 0, 0);
			hudmessage (s:""; 0, 4, 0, 0, 0, 0);
			hudmessage (s:""; 0, 6, 0, 0, 0, 0);
			hudmessage (s:""; 0, 7, 0, 0, 0, 0);
			hudmessage (s:""; 0, 8, 0, 0, 0, 0);
			if ((bonus_lev_num >= 1) && (bonus_lev_num <= 4))
			SetPlayerProperty (1, 0, 4);
			if (bonus_lev_num == 3)
			SetPlayerProperty (1, 0, 3);
			activatorsound ("teleport3", 127);
			delay(35);
			restoreTime();

			counter_ended = true;
		}
	}

	if (counter_ended)
	{
		if (forced)
		{
			delay(35);
			ssdremaster_do_scoring = false;
		}
		else
		{
			ACS_ExecuteAlways (800, 0, 0, 0, 0);
		}
	}
}

script "ssdremaster_check_achievements" (int type_id, int idx)
{
	bool done_achievement=false;

	while (ssdremaster_achievements_looped && !done_achievement)
	{
		done_achievement=true;
		int cmp1,cmp2;

		//Log(s:"Checking achievement with IDs (",d:type_id,s:",",d:idx,s:") - BEGIN");

		switch (type_id)
		{
			case SDR_ACHIEVEMENT_TYPE_GAME:
			{
				switch (idx)
				{
					case SDR_GAME_ACHIEVEMENT_ALL_MOCKS:
					{
						// GAME - ALL MOCKS

						cmp1 = ssdremaster_mock_count; cmp2 = SSDREMASTER_MOCK_MAX_COUNT;
						done_achievement &= (cmp1 == cmp2);

						//Log(s:"(",d:type_id,s:",",d:idx,s:"): ",d:cmp1,s:" == ",d:cmp2,s:" ?");
					} break;
					default: break;
				}
			} break;
			case SDR_ACHIEVEMENT_TYPE_MAP:
			{
				switch (idx)
				{
					case SDR_MAP_ACHIEVEMENT_PERFECT:
					{
						// MAP - PERFECT
						cmp1 = secretbonus_basic_settings[1]; cmp2 = secret_count_per_level[story_lev_num-1];
						done_achievement &= (cmp1 == cmp2);
						//Log(s:"(",d:type_id,s:",",d:idx,s:"): ",d:cmp1,s:" == ",d:cmp2,s:" ?");

						cmp1 = killbonus_basic_settings[1]; cmp2 = killbonus_basic_settings[2];
						done_achievement &= (cmp1 >= cmp2);
						//Log(s:"(",d:type_id,s:",",d:idx,s:"): ",d:cmp1,s:" >= ",d:cmp2,s:" ?");
					} break;
					default: break;
				}
			} break;
			default: break;
		}

		//Log(s:"Checking achievement with IDs (",d:type_id,s:",",d:idx,s:") - END");

		Delay(20);
	}

	if (done_achievement)
	{
		//Log(s:"Reached achievement with IDs (",d:type_id,s:",",d:idx,s:").");

		switch (type_id)
		{
			case SDR_ACHIEVEMENT_TYPE_GAME:
			{
				ssdremaster_game_achievements[0]++;
				ssdremaster_game_achievements[ ssdremaster_map_achievements[0] ] = idx;
			} break;
			case SDR_ACHIEVEMENT_TYPE_MAP:
			{
				ssdremaster_map_achievements[0]++;
				ssdremaster_map_achievements[ ssdremaster_map_achievements[0] ] = idx;
			} break;
			default: break;
		}
	}	
}

script "ssdremaster_log_achievements" (void)
{
	int i,j;

	for (j=0;j<SDR_ACHIEVEMENT_TYPE_N;j++)
	{
		int N=0;

		switch (j)
		{
			case SDR_ACHIEVEMENT_TYPE_GAME: N = ssdremaster_game_achievements[0]; break;
			case SDR_ACHIEVEMENT_TYPE_MAP: N = ssdremaster_map_achievements[0]; break;
			default: break;
		}

		if (N > 0)
		{
			str temp=StrParam(s:"Achievements #",d:j,s:": ");

			for (i=0;i<N;i++)
			{
				int e=-1;

				switch (j)
				{
					case SDR_ACHIEVEMENT_TYPE_GAME: e = ssdremaster_game_achievements[i+1]; break;
					case SDR_ACHIEVEMENT_TYPE_MAP: e = ssdremaster_map_achievements[i+1]; break;
					default: break;
				}

				if (i > 0) temp = StrParam(s:temp,s:",");
				temp = StrParam(s:temp,d:e);
			}

			Log(s:temp);
		}
	}
}